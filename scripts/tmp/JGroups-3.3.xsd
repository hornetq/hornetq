<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified" targetNamespace="urn:org:jgroups">
 <xs:element name="config">
  <xs:complexType>
   <xs:choice maxOccurs="unbounded">
    <xs:element name="PING">
     <xs:complexType>
      <xs:attribute name="timeout" type="xs:string">
       <xs:annotation>
        <xs:documentation>Timeout to wait for the initial members</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="num_initial_members" type="xs:string">
       <xs:annotation>
        <xs:documentation>Minimum number of initial members to get a response from</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="num_initial_srv_members" type="xs:string">
       <xs:annotation>
        <xs:documentation>Minimum number of server responses (PingData.isServer()=true). If this value is greater than 0, we'll ignore num_initial_members</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="break_on_coord_rsp" type="xs:string">
       <xs:annotation>
        <xs:documentation>Return from the discovery phase as soon as we have 1 coordinator response</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="return_entire_cache" type="xs:string">
       <xs:annotation>
        <xs:documentation>Whether or not to return the entire logical-physical address cache mappings on a discovery request, or not.</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="stagger_timeout" type="xs:string">
       <xs:annotation>
        <xs:documentation>If greater than 0, we'll wait a random number of milliseconds in range [0..stagger_timeout] before sending a discovery response. This prevents traffic spikes in large clusters when everyone sends their discovery response at the same time</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="force_sending_discovery_rsps" type="xs:string">
       <xs:annotation>
        <xs:documentation>Always sends a discovery response, no matter what</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="use_disk_cache" type="xs:string">
       <xs:annotation>
        <xs:documentation>If a persistent disk cache (PDC) is present, combine the discovery results with the contents of the disk cache before returning the results</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="stats" type="xs:string">
       <xs:annotation>
        <xs:documentation>Determines whether to collect statistics (and expose them via JMX). Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="ergonomics" type="xs:string">
       <xs:annotation>
        <xs:documentation>Enables ergonomics: dynamically find the best values for properties at runtime</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="name" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different name if needed so we can have multiple instances of it in the same stack (also change ID)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="id" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different ID if needed so we can have multiple instances of it in the same stack</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="level" type="xs:string">
       <xs:annotation>
        <xs:documentation>Sets the logger level (see javadocs)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
     </xs:complexType>
    </xs:element>
    <xs:element name="S3_PING">
     <xs:complexType>
      <xs:attribute name="access_key" type="xs:string">
       <xs:annotation>
        <xs:documentation>The access key to AWS (S3)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="secret_access_key" type="xs:string">
       <xs:annotation>
        <xs:documentation>The secret access key to AWS (S3)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="prefix" type="xs:string">
       <xs:annotation>
        <xs:documentation>When non-null, we set location to prefix-UUID</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="pre_signed_put_url" type="xs:string">
       <xs:annotation>
        <xs:documentation>When non-null, we use this pre-signed URL for PUTs</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="pre_signed_delete_url" type="xs:string">
       <xs:annotation>
        <xs:documentation>When non-null, we use this pre-signed URL for DELETEs</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="location" type="xs:string">
       <xs:annotation>
        <xs:documentation>The absolute path of the shared file</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="interval" type="xs:string">
       <xs:annotation>
        <xs:documentation>Interval (in milliseconds) at which the own Address is written. 0 disables it.</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="timeout" type="xs:string">
       <xs:annotation>
        <xs:documentation>Timeout to wait for the initial members</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="num_initial_members" type="xs:string">
       <xs:annotation>
        <xs:documentation>Minimum number of initial members to get a response from</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="num_initial_srv_members" type="xs:string">
       <xs:annotation>
        <xs:documentation>Minimum number of server responses (PingData.isServer()=true). If this value is greater than 0, we'll ignore num_initial_members</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="break_on_coord_rsp" type="xs:string">
       <xs:annotation>
        <xs:documentation>Return from the discovery phase as soon as we have 1 coordinator response</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="return_entire_cache" type="xs:string">
       <xs:annotation>
        <xs:documentation>Whether or not to return the entire logical-physical address cache mappings on a discovery request, or not.</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="stagger_timeout" type="xs:string">
       <xs:annotation>
        <xs:documentation>If greater than 0, we'll wait a random number of milliseconds in range [0..stagger_timeout] before sending a discovery response. This prevents traffic spikes in large clusters when everyone sends their discovery response at the same time</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="force_sending_discovery_rsps" type="xs:string">
       <xs:annotation>
        <xs:documentation>Always sends a discovery response, no matter what</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="use_disk_cache" type="xs:string">
       <xs:annotation>
        <xs:documentation>If a persistent disk cache (PDC) is present, combine the discovery results with the contents of the disk cache before returning the results</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="stats" type="xs:string">
       <xs:annotation>
        <xs:documentation>Determines whether to collect statistics (and expose them via JMX). Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="ergonomics" type="xs:string">
       <xs:annotation>
        <xs:documentation>Enables ergonomics: dynamically find the best values for properties at runtime</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="name" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different name if needed so we can have multiple instances of it in the same stack (also change ID)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="id" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different ID if needed so we can have multiple instances of it in the same stack</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="level" type="xs:string">
       <xs:annotation>
        <xs:documentation>Sets the logger level (see javadocs)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
     </xs:complexType>
    </xs:element>
    <xs:element name="CENTRAL_LOCK">
     <xs:complexType>
      <xs:attribute name="num_backups" type="xs:string">
       <xs:annotation>
        <xs:documentation>Number of backups to the coordinator. Server locks get replicated to these nodes as well</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="bypass_bundling" type="xs:string">
       <xs:annotation>
        <xs:documentation>bypasses message bundling if set</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="lock_striping_size" type="xs:string">
       <xs:annotation>
        <xs:documentation>Number of locks to be used for lock striping (for synchronized access to the server_lock entries)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="stats" type="xs:string">
       <xs:annotation>
        <xs:documentation>Determines whether to collect statistics (and expose them via JMX). Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="ergonomics" type="xs:string">
       <xs:annotation>
        <xs:documentation>Enables ergonomics: dynamically find the best values for properties at runtime</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="name" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different name if needed so we can have multiple instances of it in the same stack (also change ID)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="id" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different ID if needed so we can have multiple instances of it in the same stack</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="level" type="xs:string">
       <xs:annotation>
        <xs:documentation>Sets the logger level (see javadocs)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
     </xs:complexType>
    </xs:element>
    <xs:element name="BARRIER">
     <xs:complexType>
      <xs:attribute name="max_close_time" type="xs:string">
       <xs:annotation>
        <xs:documentation>Max time barrier can be closed. Default is 60000 ms</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="stats" type="xs:string">
       <xs:annotation>
        <xs:documentation>Determines whether to collect statistics (and expose them via JMX). Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="ergonomics" type="xs:string">
       <xs:annotation>
        <xs:documentation>Enables ergonomics: dynamically find the best values for properties at runtime</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="name" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different name if needed so we can have multiple instances of it in the same stack (also change ID)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="id" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different ID if needed so we can have multiple instances of it in the same stack</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="level" type="xs:string">
       <xs:annotation>
        <xs:documentation>Sets the logger level (see javadocs)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
     </xs:complexType>
    </xs:element>
    <xs:element name="RACKSPACE_PING">
     <xs:complexType>
      <xs:attribute name="username" type="xs:string">
       <xs:annotation>
        <xs:documentation>Rackspace username</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="apiKey" type="xs:string">
       <xs:annotation>
        <xs:documentation>Rackspace API access key</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="region" type="xs:string">
       <xs:annotation>
        <xs:documentation>Rackspace region, either UK or US</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="container" type="xs:string">
       <xs:annotation>
        <xs:documentation>Name of the root container</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="location" type="xs:string">
       <xs:annotation>
        <xs:documentation>The absolute path of the shared file</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="interval" type="xs:string">
       <xs:annotation>
        <xs:documentation>Interval (in milliseconds) at which the own Address is written. 0 disables it.</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="timeout" type="xs:string">
       <xs:annotation>
        <xs:documentation>Timeout to wait for the initial members</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="num_initial_members" type="xs:string">
       <xs:annotation>
        <xs:documentation>Minimum number of initial members to get a response from</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="num_initial_srv_members" type="xs:string">
       <xs:annotation>
        <xs:documentation>Minimum number of server responses (PingData.isServer()=true). If this value is greater than 0, we'll ignore num_initial_members</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="break_on_coord_rsp" type="xs:string">
       <xs:annotation>
        <xs:documentation>Return from the discovery phase as soon as we have 1 coordinator response</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="return_entire_cache" type="xs:string">
       <xs:annotation>
        <xs:documentation>Whether or not to return the entire logical-physical address cache mappings on a discovery request, or not.</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="stagger_timeout" type="xs:string">
       <xs:annotation>
        <xs:documentation>If greater than 0, we'll wait a random number of milliseconds in range [0..stagger_timeout] before sending a discovery response. This prevents traffic spikes in large clusters when everyone sends their discovery response at the same time</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="force_sending_discovery_rsps" type="xs:string">
       <xs:annotation>
        <xs:documentation>Always sends a discovery response, no matter what</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="use_disk_cache" type="xs:string">
       <xs:annotation>
        <xs:documentation>If a persistent disk cache (PDC) is present, combine the discovery results with the contents of the disk cache before returning the results</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="stats" type="xs:string">
       <xs:annotation>
        <xs:documentation>Determines whether to collect statistics (and expose them via JMX). Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="ergonomics" type="xs:string">
       <xs:annotation>
        <xs:documentation>Enables ergonomics: dynamically find the best values for properties at runtime</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="name" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different name if needed so we can have multiple instances of it in the same stack (also change ID)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="id" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different ID if needed so we can have multiple instances of it in the same stack</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="level" type="xs:string">
       <xs:annotation>
        <xs:documentation>Sets the logger level (see javadocs)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
     </xs:complexType>
    </xs:element>
    <xs:element name="DISCARD_PAYLOAD">
     <xs:complexType>
      <xs:attribute name="seqno" type="xs:string">
       <xs:annotation>
        <xs:documentation/>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="duplicate" type="xs:string">
       <xs:annotation>
        <xs:documentation/>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="stats" type="xs:string">
       <xs:annotation>
        <xs:documentation>Determines whether to collect statistics (and expose them via JMX). Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="ergonomics" type="xs:string">
       <xs:annotation>
        <xs:documentation>Enables ergonomics: dynamically find the best values for properties at runtime</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="name" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different name if needed so we can have multiple instances of it in the same stack (also change ID)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="id" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different ID if needed so we can have multiple instances of it in the same stack</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="level" type="xs:string">
       <xs:annotation>
        <xs:documentation>Sets the logger level (see javadocs)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
     </xs:complexType>
    </xs:element>
    <xs:element name="FORWARD_TO_COORD">
     <xs:complexType>
      <xs:attribute name="resend_delay" type="xs:string">
       <xs:annotation>
        <xs:documentation>The delay (in ms) to wait until we resend a message to member P after P told us that it isn't the coordinator. Thsi can happen when we see P as new coordinator, but P hasn't yet installed the view which makes it coordinator (perhaps due to a slight delay)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="stats" type="xs:string">
       <xs:annotation>
        <xs:documentation>Determines whether to collect statistics (and expose them via JMX). Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="ergonomics" type="xs:string">
       <xs:annotation>
        <xs:documentation>Enables ergonomics: dynamically find the best values for properties at runtime</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="name" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different name if needed so we can have multiple instances of it in the same stack (also change ID)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="id" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different ID if needed so we can have multiple instances of it in the same stack</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="level" type="xs:string">
       <xs:annotation>
        <xs:documentation>Sets the logger level (see javadocs)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
     </xs:complexType>
    </xs:element>
    <xs:element name="TRACE">
     <xs:complexType>
      <xs:attribute name="stats" type="xs:string">
       <xs:annotation>
        <xs:documentation>Determines whether to collect statistics (and expose them via JMX). Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="ergonomics" type="xs:string">
       <xs:annotation>
        <xs:documentation>Enables ergonomics: dynamically find the best values for properties at runtime</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="name" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different name if needed so we can have multiple instances of it in the same stack (also change ID)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="id" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different ID if needed so we can have multiple instances of it in the same stack</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="level" type="xs:string">
       <xs:annotation>
        <xs:documentation>Sets the logger level (see javadocs)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
     </xs:complexType>
    </xs:element>
    <xs:element name="UNICAST">
     <xs:complexType>
      <xs:attribute name="max_msg_batch_size" type="xs:string">
       <xs:annotation>
        <xs:documentation>Max number of messages to be removed from a retransmit window. This property might get removed anytime, so don't use it !</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="conn_expiry_timeout" type="xs:string">
       <xs:annotation>
        <xs:documentation>Time (in milliseconds) after which an idle incoming or outgoing connection is closed. The connection will get re-established when used again. 0 disables connection reaping</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="segment_capacity" type="xs:string">
       <xs:annotation>
        <xs:documentation>Size (in bytes) of a Segment in the segments table. Only for experts, do not use !</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="xmit_table_num_rows" type="xs:string">
       <xs:annotation>
        <xs:documentation>Number of rows of the matrix in the retransmission table (only for experts)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="xmit_table_msgs_per_row" type="xs:string">
       <xs:annotation>
        <xs:documentation>Number of elements of a row of the matrix in the retransmission table (only for experts). The capacity of the matrix is xmit_table_num_rows * xmit_table_msgs_per_row</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="xmit_table_resize_factor" type="xs:string">
       <xs:annotation>
        <xs:documentation>Resize factor of the matrix in the retransmission table (only for experts)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="xmit_table_max_compaction_time" type="xs:string">
       <xs:annotation>
        <xs:documentation>Number of milliseconds after which the matrix in the retransmission table is compacted (only for experts)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="xmit_interval" type="xs:string">
       <xs:annotation>
        <xs:documentation>Interval (in milliseconds) at which messages in the send windows are resent</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="stats" type="xs:string">
       <xs:annotation>
        <xs:documentation>Determines whether to collect statistics (and expose them via JMX). Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="ergonomics" type="xs:string">
       <xs:annotation>
        <xs:documentation>Enables ergonomics: dynamically find the best values for properties at runtime</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="name" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different name if needed so we can have multiple instances of it in the same stack (also change ID)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="id" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different ID if needed so we can have multiple instances of it in the same stack</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="timeout" type="xs:string"/>
      <xs:attribute name="max_retransmit_time" type="xs:string">
       <xs:annotation>
        <xs:documentation>Max number of milliseconds we try to retransmit a message to any given member. After that, the connection is removed. Any new connection to that member will start with seqno #1 again. 0 disables this</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="level" type="xs:string">
       <xs:annotation>
        <xs:documentation>Sets the logger level (see javadocs)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
     </xs:complexType>
    </xs:element>
    <xs:element name="RSVP">
     <xs:complexType>
      <xs:attribute name="timeout" type="xs:string">
       <xs:annotation>
        <xs:documentation>Max time in milliseconds to block for an RSVP'ed message (0 blocks forever).</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="throw_exception_on_timeout" type="xs:string">
       <xs:annotation>
        <xs:documentation>Whether an exception should be thrown when the timeout kicks in, and we haven't yet received all acks. An exception would be thrown all the way up to JChannel.send()</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="ack_on_delivery" type="xs:string">
       <xs:annotation>
        <xs:documentation>When true, we pass the message up to the application and only then send an ack. When false, we send an ack first and only then pass the message up to the application.</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="resend_interval" type="xs:string">
       <xs:annotation>
        <xs:documentation>Interval (in milliseconds) at which we resend the RSVP request. Needs to be &lt; timeout. 0 disables it.</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="stats" type="xs:string">
       <xs:annotation>
        <xs:documentation>Determines whether to collect statistics (and expose them via JMX). Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="ergonomics" type="xs:string">
       <xs:annotation>
        <xs:documentation>Enables ergonomics: dynamically find the best values for properties at runtime</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="name" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different name if needed so we can have multiple instances of it in the same stack (also change ID)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="id" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different ID if needed so we can have multiple instances of it in the same stack</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="level" type="xs:string">
       <xs:annotation>
        <xs:documentation>Sets the logger level (see javadocs)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
     </xs:complexType>
    </xs:element>
    <xs:element name="ProtocolAdapter">
     <xs:complexType>
      <xs:attribute name="stats" type="xs:string">
       <xs:annotation>
        <xs:documentation>Determines whether to collect statistics (and expose them via JMX). Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="ergonomics" type="xs:string">
       <xs:annotation>
        <xs:documentation>Enables ergonomics: dynamically find the best values for properties at runtime</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="name" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different name if needed so we can have multiple instances of it in the same stack (also change ID)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="id" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different ID if needed so we can have multiple instances of it in the same stack</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="level" type="xs:string">
       <xs:annotation>
        <xs:documentation>Sets the logger level (see javadocs)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
     </xs:complexType>
    </xs:element>
    <xs:element name="STOMP">
     <xs:complexType>
      <xs:attribute name="bind_addr" type="xs:string">
       <xs:annotation>
        <xs:documentation>The bind address which should be used by the server socket. The following special values are also recognized: GLOBAL, SITE_LOCAL, LINK_LOCAL and NON_LOOPBACK</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="endpoint_addr" type="xs:string">
       <xs:annotation>
        <xs:documentation>If set, then endpoint will be set to this address</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="port" type="xs:string">
       <xs:annotation>
        <xs:documentation>Port on which the STOMP protocol listens for requests</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="exact_destination_match" type="xs:string">
       <xs:annotation>
        <xs:documentation>If set to false, then a destination of /a/b match /a/b/c, a/b/d, a/b/c/d etc</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="send_info" type="xs:string">
       <xs:annotation>
        <xs:documentation>If true, information such as a list of endpoints, or views, will be sent to all clients (via the INFO command). This allows for example intelligent clients to connect to a different server should a connection be closed.</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="forward_non_client_generated_msgs" type="xs:string">
       <xs:annotation>
        <xs:documentation>Forward received messages which don't have a StompHeader to clients</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="stats" type="xs:string">
       <xs:annotation>
        <xs:documentation>Determines whether to collect statistics (and expose them via JMX). Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="ergonomics" type="xs:string">
       <xs:annotation>
        <xs:documentation>Enables ergonomics: dynamically find the best values for properties at runtime</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="name" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different name if needed so we can have multiple instances of it in the same stack (also change ID)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="id" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different ID if needed so we can have multiple instances of it in the same stack</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="level" type="xs:string">
       <xs:annotation>
        <xs:documentation>Sets the logger level (see javadocs)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
     </xs:complexType>
    </xs:element>
    <xs:element name="PRIO">
     <xs:complexType>
      <xs:attribute name="message_failure_sleep_time" type="xs:string">
       <xs:annotation>
        <xs:documentation>The number of miliseconds to sleep before after an error occurs before sending the next message</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="prioritize_down" type="xs:string">
       <xs:annotation>
        <xs:documentation>true to prioritize outgoing messages</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="prioritize_up" type="xs:string">
       <xs:annotation>
        <xs:documentation>true to prioritize incoming messages</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="stats" type="xs:string">
       <xs:annotation>
        <xs:documentation>Determines whether to collect statistics (and expose them via JMX). Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="ergonomics" type="xs:string">
       <xs:annotation>
        <xs:documentation>Enables ergonomics: dynamically find the best values for properties at runtime</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="name" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different name if needed so we can have multiple instances of it in the same stack (also change ID)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="id" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different ID if needed so we can have multiple instances of it in the same stack</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="level" type="xs:string">
       <xs:annotation>
        <xs:documentation>Sets the logger level (see javadocs)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
     </xs:complexType>
    </xs:element>
    <xs:element name="TCP_NIO">
     <xs:complexType>
      <xs:attribute name="reader_threads" type="xs:string">
       <xs:annotation>
        <xs:documentation/>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="writer_threads" type="xs:string">
       <xs:annotation>
        <xs:documentation/>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="processor_threads" type="xs:string">
       <xs:annotation>
        <xs:documentation/>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="processor_minThreads" type="xs:string">
       <xs:annotation>
        <xs:documentation/>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="processor_maxThreads" type="xs:string">
       <xs:annotation>
        <xs:documentation/>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="processor_queueSize" type="xs:string">
       <xs:annotation>
        <xs:documentation/>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="processor_keepAliveTime" type="xs:string">
       <xs:annotation>
        <xs:documentation/>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="reaper_interval" type="xs:string">
       <xs:annotation>
        <xs:documentation>Reaper interval in msec. Default is 0 (no reaping)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="conn_expire_time" type="xs:string">
       <xs:annotation>
        <xs:documentation>Max time connection can be idle before being reaped (in ms)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="use_send_queues" type="xs:string">
       <xs:annotation>
        <xs:documentation>Should separate send queues be used for each connection</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="send_queue_size" type="xs:string">
       <xs:annotation>
        <xs:documentation>Max number of messages in a send queue</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="recv_buf_size" type="xs:string">
       <xs:annotation>
        <xs:documentation>Receiver buffer size in bytes</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="send_buf_size" type="xs:string">
       <xs:annotation>
        <xs:documentation>Send buffer size in bytes</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="sock_conn_timeout" type="xs:string">
       <xs:annotation>
        <xs:documentation>Max time allowed for a socket creation in connection table</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="peer_addr_read_timeout" type="xs:string">
       <xs:annotation>
        <xs:documentation>Max time to block on reading of peer address</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="tcp_nodelay" type="xs:string">
       <xs:annotation>
        <xs:documentation>Should TCP no delay flag be turned on</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="linger" type="xs:string">
       <xs:annotation>
        <xs:documentation>SO_LINGER in msec. Default of -1 disables it</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="client_bind_addr" type="xs:string">
       <xs:annotation>
        <xs:documentation>The address of a local network interface which should be used by client sockets to bind to. The following special values are also recognized: GLOBAL, SITE_LOCAL, LINK_LOCAL and NON_LOOPBACK</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="client_bind_port" type="xs:string">
       <xs:annotation>
        <xs:documentation>The local port a client socket should bind to. If 0, an ephemeral port will be picked.</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="defer_client_bind_addr" type="xs:string">
       <xs:annotation>
        <xs:documentation>If true, client sockets will not explicitly bind to bind_addr but will defer to the native socket</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="bind_addr" type="xs:string">
       <xs:annotation>
        <xs:documentation>The bind address which should be used by this transport. The following special values are also recognized: GLOBAL, SITE_LOCAL, LINK_LOCAL, NON_LOOPBACK, match-interface, match-host, match-address</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="external_addr" type="xs:string">
       <xs:annotation>
        <xs:documentation>Use "external_addr" if you have hosts on different networks, behind firewalls. On each firewall, set up a port forwarding rule (sometimes called "virtual server") to the local IP (e.g. 192.168.1.100) of the host then on each host, set "external_addr" TCP transport parameter to the external (public IP) address of the firewall.</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="external_port" type="xs:string">
       <xs:annotation>
        <xs:documentation>Used to map the internal port (bind_port) to an external port. Only used if &gt; 0</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="bind_interface" type="xs:string">
       <xs:annotation>
        <xs:documentation>The interface (NIC) which should be used by this transport</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="receive_on_all_interfaces" type="xs:string">
       <xs:annotation>
        <xs:documentation>If true, the transport should use all available interfaces to receive multicast messages</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="receive_interfaces" type="xs:string">
       <xs:annotation>
        <xs:documentation>Comma delimited list of interfaces (IP addresses or interface names) to receive multicasts on</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="logical_addr_cache_max_size" type="xs:string">
       <xs:annotation>
        <xs:documentation>Max number of elements in the logical address cache before eviction starts</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="logical_addr_cache_expiration" type="xs:string">
       <xs:annotation>
        <xs:documentation>Time (in ms) after which entries in the logical address cache marked as removable are removed</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="bind_port" type="xs:string">
       <xs:annotation>
        <xs:documentation>The port to which the transport binds. Default of 0 binds to any (ephemeral) port</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="port_range" type="xs:string">
       <xs:annotation>
        <xs:documentation>The range of valid ports, from bind_port to end_port. 0 only binds to bind_port and fails if taken</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="loopback" type="xs:string">
       <xs:annotation>
        <xs:documentation>Messages to self are looped back immediately if true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="discard_incompatible_packets" type="xs:string">
       <xs:annotation>
        <xs:documentation>Discard packets with a different version if true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="thread_naming_pattern" type="xs:string">
       <xs:annotation>
        <xs:documentation>Thread naming pattern for threads in this channel. Valid values are "pcl": "p": includes the thread name, e.g. "Incoming thread-1", "UDP ucast receiver", "c": includes the cluster name, e.g. "MyCluster", "l": includes the local address of the current member, e.g. "192.168.5.1:5678"</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="oob_thread_pool.enabled" type="xs:string">
       <xs:annotation>
        <xs:documentation>Switch for enabling thread pool for OOB messages. Default=true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="oob_thread_pool.queue_enabled" type="xs:string">
       <xs:annotation>
        <xs:documentation>Use queue to enqueue incoming OOB messages</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="oob_thread_pool.queue_max_size" type="xs:string">
       <xs:annotation>
        <xs:documentation>Maximum queue size for incoming OOB messages</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="oob_thread_pool.rejection_policy" type="xs:string">
       <xs:annotation>
        <xs:documentation>Thread rejection policy. Possible values are Abort, Discard, DiscardOldest and Run</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="thread_pool.enabled" type="xs:string">
       <xs:annotation>
        <xs:documentation>Switch for enabling thread pool for regular messages</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="thread_pool.queue_enabled" type="xs:string">
       <xs:annotation>
        <xs:documentation>Queue to enqueue incoming regular messages</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="thread_pool.queue_max_size" type="xs:string">
       <xs:annotation>
        <xs:documentation>Maximum queue size for incoming OOB messages</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="thread_pool.rejection_policy" type="xs:string">
       <xs:annotation>
        <xs:documentation>Thread rejection policy. Possible values are Abort, Discard, DiscardOldest and Run</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="internal_thread_pool.enabled" type="xs:string">
       <xs:annotation>
        <xs:documentation>Switch for enabling thread pool for internal messages</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="internal_thread_pool.min_threads" type="xs:string">
       <xs:annotation>
        <xs:documentation>Minimum thread pool size for the internal thread pool</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="internal_thread_pool.max_threads" type="xs:string">
       <xs:annotation>
        <xs:documentation>Maximum thread pool size for the internal thread pool</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="internal_thread_pool.keep_alive_time" type="xs:string">
       <xs:annotation>
        <xs:documentation>Timeout in ms to remove idle threads from the internal pool</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="internal_thread_pool.queue_enabled" type="xs:string">
       <xs:annotation>
        <xs:documentation>Queue to enqueue incoming internal messages</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="internal_thread_pool.queue_max_size" type="xs:string">
       <xs:annotation>
        <xs:documentation>Maximum queue size for incoming internal messages</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="internal_thread_pool.rejection_policy" type="xs:string">
       <xs:annotation>
        <xs:documentation>Thread rejection policy. Possible values are Abort, Discard, DiscardOldest and Run</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="timer_type" type="xs:string">
       <xs:annotation>
        <xs:documentation>Type of timer to be used. Valid values are "old" (DefaultTimeScheduler, used up to 2.10), "new" or "new2" (TimeScheduler2), "new3" (TimeScheduler3) and "wheel". Note that this property might disappear in future releases, if one of the 3 timers is chosen as default timer</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="timer.queue_max_size" type="xs:string">
       <xs:annotation>
        <xs:documentation>Max number of elements on a timer queue</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="timer.rejection_policy" type="xs:string">
       <xs:annotation>
        <xs:documentation>Timer rejection policy. Possible values are Abort, Discard, DiscardOldest and Run</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="timer.wheel_size" type="xs:string">
       <xs:annotation>
        <xs:documentation>Number of ticks in the HashedTimingWheel timer. Only applicable if timer_type is "wheel"</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="timer.tick_time" type="xs:string">
       <xs:annotation>
        <xs:documentation>Tick duration in the HashedTimingWheel timer. Only applicable if timer_type is "wheel"</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="enable_bundling" type="xs:string">
       <xs:annotation>
        <xs:documentation>Enable bundling of smaller messages into bigger ones. Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="enable_unicast_bundling" type="xs:string">
       <xs:annotation>
        <xs:documentation>Enable bundling of smaller messages into bigger ones for unicast messages. Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="enable_batching" type="xs:string">
       <xs:annotation>
        <xs:documentation>Allows the transport to pass received message batches up as MessagesBatch instances (up(MessageBatch)), rather than individual messages. This flag will be removed in a future version when batching has been implemented by all protocols</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="enable_diagnostics" type="xs:string">
       <xs:annotation>
        <xs:documentation>Switch to enable diagnostic probing. Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="diagnostics_addr" type="xs:string">
       <xs:annotation>
        <xs:documentation>Address for diagnostic probing. Default is 224.0.75.75</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="diagnostics_bind_interfaces" type="xs:string">
       <xs:annotation>
        <xs:documentation>Comma delimited list of interfaces (IP addresses or interface names) that the diagnostics multicast socket should bind to</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="diagnostics_port" type="xs:string">
       <xs:annotation>
        <xs:documentation>Port for diagnostic probing. Default is 7500</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="diagnostics_ttl" type="xs:string">
       <xs:annotation>
        <xs:documentation>TTL of the diagnostics multicast socket</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="diagnostics_passcode" type="xs:string">
       <xs:annotation>
        <xs:documentation>Authorization passcode for diagnostics. If specified every probe query will be authorized</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="singleton_name" type="xs:string">
       <xs:annotation>
        <xs:documentation>If assigned enable this transport to be a singleton (shared) transport</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="log_discard_msgs" type="xs:string">
       <xs:annotation>
        <xs:documentation>whether or not warnings about messages from different groups are logged</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="log_discard_msgs_version" type="xs:string">
       <xs:annotation>
        <xs:documentation>whether or not warnings about messages from members with a different version are discarded</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="who_has_cache_timeout" type="xs:string">
       <xs:annotation>
        <xs:documentation>Timeout (in ms) to determine how long to wait until a request to fetch the physical address for a given logical address will be sent again. Subsequent requests for the same physical address will therefore be spaced at least who_has_cache_timeout ms apart</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="physical_addr_max_fetch_attempts" type="xs:string">
       <xs:annotation>
        <xs:documentation>Max number of attempts to fetch a physical address (when not in the cache) before giving up</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="suppress_time_different_version_warnings" type="xs:string">
       <xs:annotation>
        <xs:documentation>Time during which identical warnings about messages from a member with a different version will be suppressed. 0 disables this (every warning will be logged). Setting the log level to ERROR also disables this.</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="suppress_time_different_cluster_warnings" type="xs:string">
       <xs:annotation>
        <xs:documentation>Time during which identical warnings about messages from a member from a different cluster will be suppressed. 0 disables this (every warning will be logged). Setting the log level to ERROR also disables this.</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="bundler_type" type="xs:string">
       <xs:annotation>
        <xs:documentation>The type of bundler used. Has to be "old" or "new" (default)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="bundler_capacity" type="xs:string">
       <xs:annotation>
        <xs:documentation>The max number of elements in a bundler if the bundler supports size limitations</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="stats" type="xs:string">
       <xs:annotation>
        <xs:documentation>Determines whether to collect statistics (and expose them via JMX). Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="ergonomics" type="xs:string">
       <xs:annotation>
        <xs:documentation>Enables ergonomics: dynamically find the best values for properties at runtime</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="name" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different name if needed so we can have multiple instances of it in the same stack (also change ID)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="id" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different ID if needed so we can have multiple instances of it in the same stack</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="max_bundle_size" type="xs:string">
       <xs:annotation>
        <xs:documentation>Maximum number of bytes for messages to be queued until they are sent</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="max_bundle_timeout" type="xs:string">
       <xs:annotation>
        <xs:documentation>Max number of milliseconds until queued messages are sent</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="oob_thread_pool.keep_alive_time" type="xs:string">
       <xs:annotation>
        <xs:documentation>Timeout in ms to remove idle threads from the OOB pool</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="oob_thread_pool.min_threads" type="xs:string">
       <xs:annotation>
        <xs:documentation>Minimum thread pool size for the OOB thread pool</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="oob_thread_pool.max_threads" type="xs:string">
       <xs:annotation>
        <xs:documentation>Max thread pool size for the OOB thread pool</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="thread_pool.min_threads" type="xs:string">
       <xs:annotation>
        <xs:documentation>Minimum thread pool size for the regular thread pool</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="thread_pool.max_threads" type="xs:string">
       <xs:annotation>
        <xs:documentation>Maximum thread pool size for the regular thread pool</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="thread_pool.keep_alive_time" type="xs:string">
       <xs:annotation>
        <xs:documentation>Timeout in milliseconds to remove idle thread from regular pool</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="timer.min_threads" type="xs:string">
       <xs:annotation>
        <xs:documentation>Minimum thread pool size for the timer thread pool</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="timer.max_threads" type="xs:string">
       <xs:annotation>
        <xs:documentation>Max thread pool size for the timer thread pool</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="timer.keep_alive_time" type="xs:string">
       <xs:annotation>
        <xs:documentation>Timeout in ms to remove idle threads from the timer pool</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="level" type="xs:string">
       <xs:annotation>
        <xs:documentation>Sets the logger level (see javadocs)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
     </xs:complexType>
    </xs:element>
    <xs:element name="MFC">
     <xs:complexType>
      <xs:attribute name="max_credits" type="xs:string">
       <xs:annotation>
        <xs:documentation>Max number of bytes to send per receiver until an ack must be received to proceed</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="max_block_time" type="xs:string">
       <xs:annotation>
        <xs:documentation>Max time (in milliseconds) to block. Default is 5000 msec</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="min_threshold" type="xs:string">
       <xs:annotation>
        <xs:documentation>The threshold (as a percentage of max_credits) at which a receiver sends more credits to a sender. Example: if max_credits is 1'000'000, and min_threshold 0.25, then we send ca. 250'000 credits to P once we've got only 250'000 credits left for P (we've received 750'000 bytes from P)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="min_credits" type="xs:string">
       <xs:annotation>
        <xs:documentation>Computed as max_credits x min_theshold unless explicitly set</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="ignore_synchronous_response" type="xs:string">
       <xs:annotation>
        <xs:documentation>Does not block a down message if it is a result of handling an up message in thesame thread. Fixes JGRP-928</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="stats" type="xs:string">
       <xs:annotation>
        <xs:documentation>Determines whether to collect statistics (and expose them via JMX). Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="ergonomics" type="xs:string">
       <xs:annotation>
        <xs:documentation>Enables ergonomics: dynamically find the best values for properties at runtime</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="name" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different name if needed so we can have multiple instances of it in the same stack (also change ID)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="id" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different ID if needed so we can have multiple instances of it in the same stack</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="max_block_times" type="xs:string">
       <xs:annotation>
        <xs:documentation>Max times to block for the listed messages sizes (Message.getLength()). Example: "1000:10,5000:30,10000:500"</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="level" type="xs:string">
       <xs:annotation>
        <xs:documentation>Sets the logger level (see javadocs)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
     </xs:complexType>
    </xs:element>
    <xs:element name="FC">
     <xs:complexType>
      <xs:attribute name="max_credits" type="xs:string">
       <xs:annotation>
        <xs:documentation>Max number of bytes to send per receiver until an ack must be received to proceed. Default is 500000 bytes</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="max_block_time" type="xs:string">
       <xs:annotation>
        <xs:documentation>Max time (in milliseconds) to block. Default is 5000 msec</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="min_threshold" type="xs:string">
       <xs:annotation>
        <xs:documentation>The threshold (as a percentage of max_credits) at which a receiver sends more credits to a sender. Example: if max_credits is 1'000'000, and min_threshold 0.25, then we send ca. 250'000 credits to P once we've received 250'000 bytes from P</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="min_credits" type="xs:string">
       <xs:annotation>
        <xs:documentation>Computed as max_credits x min_theshold unless explicitly set</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="ignore_synchronous_response" type="xs:string">
       <xs:annotation>
        <xs:documentation>Does not block a down message if it is a result of handling an up message in thesame thread. Fixes JGRP-928</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="stats" type="xs:string">
       <xs:annotation>
        <xs:documentation>Determines whether to collect statistics (and expose them via JMX). Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="ergonomics" type="xs:string">
       <xs:annotation>
        <xs:documentation>Enables ergonomics: dynamically find the best values for properties at runtime</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="name" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different name if needed so we can have multiple instances of it in the same stack (also change ID)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="id" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different ID if needed so we can have multiple instances of it in the same stack</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="max_block_times" type="xs:string">
       <xs:annotation>
        <xs:documentation>Max times to block for the listed messages sizes (Message.getLength()). Example: "1000:10,5000:30,10000:500"</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="level" type="xs:string">
       <xs:annotation>
        <xs:documentation>Sets the logger level (see javadocs)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
     </xs:complexType>
    </xs:element>
    <xs:element name="DELAY">
     <xs:complexType>
      <xs:attribute name="in_delay" type="xs:string">
       <xs:annotation>
        <xs:documentation>Number of millisconds to delay passing a message up the stack</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="out_delay" type="xs:string">
       <xs:annotation>
        <xs:documentation>Number of millisconds to delay passing a message down the stack</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="stats" type="xs:string">
       <xs:annotation>
        <xs:documentation>Determines whether to collect statistics (and expose them via JMX). Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="ergonomics" type="xs:string">
       <xs:annotation>
        <xs:documentation>Enables ergonomics: dynamically find the best values for properties at runtime</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="name" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different name if needed so we can have multiple instances of it in the same stack (also change ID)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="id" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different ID if needed so we can have multiple instances of it in the same stack</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="level" type="xs:string">
       <xs:annotation>
        <xs:documentation>Sets the logger level (see javadocs)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
     </xs:complexType>
    </xs:element>
    <xs:element name="JDBC_PING">
     <xs:complexType>
      <xs:attribute name="connection_url" type="xs:string">
       <xs:annotation>
        <xs:documentation>The JDBC connection URL</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="connection_username" type="xs:string">
       <xs:annotation>
        <xs:documentation>The JDBC connection username</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="connection_password" type="xs:string">
       <xs:annotation>
        <xs:documentation>The JDBC connection password</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="connection_driver" type="xs:string">
       <xs:annotation>
        <xs:documentation>The JDBC connection driver name</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="initialize_sql" type="xs:string">
       <xs:annotation>
        <xs:documentation>If not empty, this SQL statement will be performed at startup.Customize it to create the needed table on those databases which permit table creation attempt without loosing data, such as PostgreSQL and MySQL (using IF NOT EXISTS). To allow for creation attempts, errors performing this statement will be loggedbut not considered fatal. To avoid any DDL operation, set this to an empty string.</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="insert_single_sql" type="xs:string">
       <xs:annotation>
        <xs:documentation>SQL used to insert a new row. Customizable, but keep the order of parameters and pick compatible types: 1)Own Address, as String 2)Cluster name, as String 3)Serialized PingData as byte[]</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="delete_single_sql" type="xs:string">
       <xs:annotation>
        <xs:documentation>SQL used to delete a row. Customizable, but keep the order of parameters and pick compatible types: 1)Own Address, as String 2)Cluster name, as String</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="select_all_pingdata_sql" type="xs:string">
       <xs:annotation>
        <xs:documentation>SQL used to fetch all node's PingData. Customizable, but keep the order of parameters and pick compatible types: only one parameter needed, String compatible, representing the Cluster name. Must return a byte[], the Serialized PingData as it was stored by the insert_single_sql statement</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="datasource_jndi_name" type="xs:string">
       <xs:annotation>
        <xs:documentation>To use a DataSource registered in JNDI, specify the JNDI name here. This is an alternative to all connection_* configuration options: if this property is not empty, then all connection relatedproperties must be empty.</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="location" type="xs:string">
       <xs:annotation>
        <xs:documentation>The absolute path of the shared file</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="interval" type="xs:string">
       <xs:annotation>
        <xs:documentation>Interval (in milliseconds) at which the own Address is written. 0 disables it.</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="timeout" type="xs:string">
       <xs:annotation>
        <xs:documentation>Timeout to wait for the initial members</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="num_initial_members" type="xs:string">
       <xs:annotation>
        <xs:documentation>Minimum number of initial members to get a response from</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="num_initial_srv_members" type="xs:string">
       <xs:annotation>
        <xs:documentation>Minimum number of server responses (PingData.isServer()=true). If this value is greater than 0, we'll ignore num_initial_members</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="break_on_coord_rsp" type="xs:string">
       <xs:annotation>
        <xs:documentation>Return from the discovery phase as soon as we have 1 coordinator response</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="return_entire_cache" type="xs:string">
       <xs:annotation>
        <xs:documentation>Whether or not to return the entire logical-physical address cache mappings on a discovery request, or not.</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="stagger_timeout" type="xs:string">
       <xs:annotation>
        <xs:documentation>If greater than 0, we'll wait a random number of milliseconds in range [0..stagger_timeout] before sending a discovery response. This prevents traffic spikes in large clusters when everyone sends their discovery response at the same time</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="force_sending_discovery_rsps" type="xs:string">
       <xs:annotation>
        <xs:documentation>Always sends a discovery response, no matter what</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="use_disk_cache" type="xs:string">
       <xs:annotation>
        <xs:documentation>If a persistent disk cache (PDC) is present, combine the discovery results with the contents of the disk cache before returning the results</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="stats" type="xs:string">
       <xs:annotation>
        <xs:documentation>Determines whether to collect statistics (and expose them via JMX). Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="ergonomics" type="xs:string">
       <xs:annotation>
        <xs:documentation>Enables ergonomics: dynamically find the best values for properties at runtime</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="name" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different name if needed so we can have multiple instances of it in the same stack (also change ID)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="id" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different ID if needed so we can have multiple instances of it in the same stack</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="level" type="xs:string">
       <xs:annotation>
        <xs:documentation>Sets the logger level (see javadocs)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
     </xs:complexType>
    </xs:element>
    <xs:element name="RELAY">
     <xs:complexType>
      <xs:attribute name="site" type="xs:string">
       <xs:annotation>
        <xs:documentation>Description of the local cluster, e.g. "nyc". This is added to every address, so itshould be short. This is a mandatory property and must be set</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="bridge_props" type="xs:string">
       <xs:annotation>
        <xs:documentation>Properties of the bridge cluster (e.g. tcp.xml)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="bridge_name" type="xs:string">
       <xs:annotation>
        <xs:documentation>Name of the bridge cluster</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="relay" type="xs:string">
       <xs:annotation>
        <xs:documentation>If set to false, don't perform relaying. Used e.g. for backup clusters; unidirectional replication from one cluster to another, but not back. Can be changed at runtime</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="present_global_views" type="xs:string">
       <xs:annotation>
        <xs:documentation>Drops views received from below and instead generates global views and passes them up. A global view consists of the local view and the remote view, ordered by view ID. If true, no protocolwhich requires (local) views can sit on top of RELAY</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="stats" type="xs:string">
       <xs:annotation>
        <xs:documentation>Determines whether to collect statistics (and expose them via JMX). Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="ergonomics" type="xs:string">
       <xs:annotation>
        <xs:documentation>Enables ergonomics: dynamically find the best values for properties at runtime</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="name" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different name if needed so we can have multiple instances of it in the same stack (also change ID)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="id" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different ID if needed so we can have multiple instances of it in the same stack</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="level" type="xs:string">
       <xs:annotation>
        <xs:documentation>Sets the logger level (see javadocs)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
     </xs:complexType>
    </xs:element>
    <xs:element name="MERGE3">
     <xs:complexType>
      <xs:attribute name="max_participants_in_merge" type="xs:string">
       <xs:annotation>
        <xs:documentation>The max number of merge participants to be involved in a merge. 0 sets this to unlimited.</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="stats" type="xs:string">
       <xs:annotation>
        <xs:documentation>Determines whether to collect statistics (and expose them via JMX). Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="ergonomics" type="xs:string">
       <xs:annotation>
        <xs:documentation>Enables ergonomics: dynamically find the best values for properties at runtime</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="name" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different name if needed so we can have multiple instances of it in the same stack (also change ID)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="id" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different ID if needed so we can have multiple instances of it in the same stack</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="min_interval" type="xs:string">
       <xs:annotation>
        <xs:documentation>Minimum time in ms before sending an info message</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="max_interval" type="xs:string">
       <xs:annotation>
        <xs:documentation>Interval (in milliseconds) when the next info message will be sent. A random value is picked from range [1..max_interval]</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="level" type="xs:string">
       <xs:annotation>
        <xs:documentation>Sets the logger level (see javadocs)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
     </xs:complexType>
    </xs:element>
    <xs:element name="FILE_PING">
     <xs:complexType>
      <xs:attribute name="location" type="xs:string">
       <xs:annotation>
        <xs:documentation>The absolute path of the shared file</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="interval" type="xs:string">
       <xs:annotation>
        <xs:documentation>Interval (in milliseconds) at which the own Address is written. 0 disables it.</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="timeout" type="xs:string">
       <xs:annotation>
        <xs:documentation>Timeout to wait for the initial members</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="num_initial_members" type="xs:string">
       <xs:annotation>
        <xs:documentation>Minimum number of initial members to get a response from</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="num_initial_srv_members" type="xs:string">
       <xs:annotation>
        <xs:documentation>Minimum number of server responses (PingData.isServer()=true). If this value is greater than 0, we'll ignore num_initial_members</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="break_on_coord_rsp" type="xs:string">
       <xs:annotation>
        <xs:documentation>Return from the discovery phase as soon as we have 1 coordinator response</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="return_entire_cache" type="xs:string">
       <xs:annotation>
        <xs:documentation>Whether or not to return the entire logical-physical address cache mappings on a discovery request, or not.</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="stagger_timeout" type="xs:string">
       <xs:annotation>
        <xs:documentation>If greater than 0, we'll wait a random number of milliseconds in range [0..stagger_timeout] before sending a discovery response. This prevents traffic spikes in large clusters when everyone sends their discovery response at the same time</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="force_sending_discovery_rsps" type="xs:string">
       <xs:annotation>
        <xs:documentation>Always sends a discovery response, no matter what</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="use_disk_cache" type="xs:string">
       <xs:annotation>
        <xs:documentation>If a persistent disk cache (PDC) is present, combine the discovery results with the contents of the disk cache before returning the results</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="stats" type="xs:string">
       <xs:annotation>
        <xs:documentation>Determines whether to collect statistics (and expose them via JMX). Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="ergonomics" type="xs:string">
       <xs:annotation>
        <xs:documentation>Enables ergonomics: dynamically find the best values for properties at runtime</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="name" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different name if needed so we can have multiple instances of it in the same stack (also change ID)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="id" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different ID if needed so we can have multiple instances of it in the same stack</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="level" type="xs:string">
       <xs:annotation>
        <xs:documentation>Sets the logger level (see javadocs)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
     </xs:complexType>
    </xs:element>
    <xs:element name="RATE_LIMITER">
     <xs:complexType>
      <xs:attribute name="max_bytes" type="xs:string">
       <xs:annotation>
        <xs:documentation>Max number of bytes to be sent in time_period ms. Blocks the sender if exceeded until a new time period has started</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="time_period" type="xs:string">
       <xs:annotation>
        <xs:documentation>Number of milliseconds during which max_bytes bytes can be sent</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="stats" type="xs:string">
       <xs:annotation>
        <xs:documentation>Determines whether to collect statistics (and expose them via JMX). Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="ergonomics" type="xs:string">
       <xs:annotation>
        <xs:documentation>Enables ergonomics: dynamically find the best values for properties at runtime</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="name" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different name if needed so we can have multiple instances of it in the same stack (also change ID)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="id" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different ID if needed so we can have multiple instances of it in the same stack</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="level" type="xs:string">
       <xs:annotation>
        <xs:documentation>Sets the logger level (see javadocs)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
     </xs:complexType>
    </xs:element>
    <xs:element name="SWIFT_PING">
     <xs:complexType>
      <xs:attribute name="auth_url" type="xs:string">
       <xs:annotation>
        <xs:documentation>Authentication url</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="auth_type" type="xs:string">
       <xs:annotation>
        <xs:documentation>Authentication type</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="tenant" type="xs:string">
       <xs:annotation>
        <xs:documentation>Openstack Keystone tenant name</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="username" type="xs:string">
       <xs:annotation>
        <xs:documentation>Username</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="password" type="xs:string">
       <xs:annotation>
        <xs:documentation>Password</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="container" type="xs:string">
       <xs:annotation>
        <xs:documentation>Name of the root container</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="location" type="xs:string">
       <xs:annotation>
        <xs:documentation>The absolute path of the shared file</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="interval" type="xs:string">
       <xs:annotation>
        <xs:documentation>Interval (in milliseconds) at which the own Address is written. 0 disables it.</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="timeout" type="xs:string">
       <xs:annotation>
        <xs:documentation>Timeout to wait for the initial members</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="num_initial_members" type="xs:string">
       <xs:annotation>
        <xs:documentation>Minimum number of initial members to get a response from</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="num_initial_srv_members" type="xs:string">
       <xs:annotation>
        <xs:documentation>Minimum number of server responses (PingData.isServer()=true). If this value is greater than 0, we'll ignore num_initial_members</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="break_on_coord_rsp" type="xs:string">
       <xs:annotation>
        <xs:documentation>Return from the discovery phase as soon as we have 1 coordinator response</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="return_entire_cache" type="xs:string">
       <xs:annotation>
        <xs:documentation>Whether or not to return the entire logical-physical address cache mappings on a discovery request, or not.</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="stagger_timeout" type="xs:string">
       <xs:annotation>
        <xs:documentation>If greater than 0, we'll wait a random number of milliseconds in range [0..stagger_timeout] before sending a discovery response. This prevents traffic spikes in large clusters when everyone sends their discovery response at the same time</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="force_sending_discovery_rsps" type="xs:string">
       <xs:annotation>
        <xs:documentation>Always sends a discovery response, no matter what</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="use_disk_cache" type="xs:string">
       <xs:annotation>
        <xs:documentation>If a persistent disk cache (PDC) is present, combine the discovery results with the contents of the disk cache before returning the results</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="stats" type="xs:string">
       <xs:annotation>
        <xs:documentation>Determines whether to collect statistics (and expose them via JMX). Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="ergonomics" type="xs:string">
       <xs:annotation>
        <xs:documentation>Enables ergonomics: dynamically find the best values for properties at runtime</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="name" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different name if needed so we can have multiple instances of it in the same stack (also change ID)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="id" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different ID if needed so we can have multiple instances of it in the same stack</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="level" type="xs:string">
       <xs:annotation>
        <xs:documentation>Sets the logger level (see javadocs)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
     </xs:complexType>
    </xs:element>
    <xs:element name="DISCARD">
     <xs:complexType>
      <xs:attribute name="up" type="xs:string">
       <xs:annotation>
        <xs:documentation/>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="down" type="xs:string">
       <xs:annotation>
        <xs:documentation/>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="excludeItself" type="xs:string">
       <xs:annotation>
        <xs:documentation/>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="discard_all" type="xs:string">
       <xs:annotation>
        <xs:documentation>drop all messages (up or down)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="drop_down_unicasts" type="xs:string">
       <xs:annotation>
        <xs:documentation>Number of subsequent unicasts to drop in the down direction</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="drop_down_multicasts" type="xs:string">
       <xs:annotation>
        <xs:documentation>Number of subsequent multicasts to drop in the down direction</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="gui" type="xs:string">
       <xs:annotation>
        <xs:documentation>use a GUI or not</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="stats" type="xs:string">
       <xs:annotation>
        <xs:documentation>Determines whether to collect statistics (and expose them via JMX). Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="ergonomics" type="xs:string">
       <xs:annotation>
        <xs:documentation>Enables ergonomics: dynamically find the best values for properties at runtime</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="name" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different name if needed so we can have multiple instances of it in the same stack (also change ID)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="id" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different ID if needed so we can have multiple instances of it in the same stack</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="level" type="xs:string">
       <xs:annotation>
        <xs:documentation>Sets the logger level (see javadocs)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
     </xs:complexType>
    </xs:element>
    <xs:element name="ENCRYPT">
     <xs:complexType>
      <xs:attribute name="asym_provider" type="xs:string">
       <xs:annotation>
        <xs:documentation>Cryptographic Service Provider. Default is Bouncy Castle Provider</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="sym_provider" type="xs:string">
       <xs:annotation>
        <xs:documentation>Cryptographic Service Provider. Default is Bouncy Castle Provider</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="asym_algorithm" type="xs:string">
       <xs:annotation>
        <xs:documentation>Cipher engine transformation for asymmetric algorithm. Default is RSA</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="sym_algorithm" type="xs:string">
       <xs:annotation>
        <xs:documentation>Cipher engine transformation for symmetric algorithm. Default is AES</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="asym_init" type="xs:string">
       <xs:annotation>
        <xs:documentation>Initial public/private key length. Default is 512</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="sym_init" type="xs:string">
       <xs:annotation>
        <xs:documentation>Initial key length for matching symmetric algorithm. Default is 128</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="key_store_name" type="xs:string">
       <xs:annotation>
        <xs:documentation>File on classpath that contains keystore repository</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="store_password" type="xs:string">
       <xs:annotation>
        <xs:documentation>Password used to check the integrity/unlock the keystore. Change the default</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="key_password" type="xs:string">
       <xs:annotation>
        <xs:documentation>Password for recovering the key. Change the default</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="alias" type="xs:string">
       <xs:annotation>
        <xs:documentation>Alias used for recovering the key. Change the default</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="encrypt_entire_message" type="xs:string">
       <xs:annotation>
        <xs:documentation/>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="stats" type="xs:string">
       <xs:annotation>
        <xs:documentation>Determines whether to collect statistics (and expose them via JMX). Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="ergonomics" type="xs:string">
       <xs:annotation>
        <xs:documentation>Enables ergonomics: dynamically find the best values for properties at runtime</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="name" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different name if needed so we can have multiple instances of it in the same stack (also change ID)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="id" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different ID if needed so we can have multiple instances of it in the same stack</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="level" type="xs:string">
       <xs:annotation>
        <xs:documentation>Sets the logger level (see javadocs)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
     </xs:complexType>
    </xs:element>
    <xs:element name="AUTH">
     <xs:complexType>
      <xs:attribute name="stats" type="xs:string">
       <xs:annotation>
        <xs:documentation>Determines whether to collect statistics (and expose them via JMX). Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="ergonomics" type="xs:string">
       <xs:annotation>
        <xs:documentation>Enables ergonomics: dynamically find the best values for properties at runtime</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="name" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different name if needed so we can have multiple instances of it in the same stack (also change ID)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="id" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different ID if needed so we can have multiple instances of it in the same stack</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="auth_class" type="xs:string"/>
      <xs:attribute name="level" type="xs:string">
       <xs:annotation>
        <xs:documentation>Sets the logger level (see javadocs)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
     </xs:complexType>
    </xs:element>
    <xs:element name="SHUFFLE">
     <xs:complexType>
      <xs:attribute name="up" type="xs:string">
       <xs:annotation>
        <xs:documentation/>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="down" type="xs:string">
       <xs:annotation>
        <xs:documentation/>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="max_size" type="xs:string">
       <xs:annotation>
        <xs:documentation>max number of messages before we bundle</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="max_time" type="xs:string">
       <xs:annotation>
        <xs:documentation>max time (ms) before we pass the bundled messages up or down</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="stats" type="xs:string">
       <xs:annotation>
        <xs:documentation>Determines whether to collect statistics (and expose them via JMX). Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="ergonomics" type="xs:string">
       <xs:annotation>
        <xs:documentation>Enables ergonomics: dynamically find the best values for properties at runtime</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="name" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different name if needed so we can have multiple instances of it in the same stack (also change ID)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="id" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different ID if needed so we can have multiple instances of it in the same stack</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="level" type="xs:string">
       <xs:annotation>
        <xs:documentation>Sets the logger level (see javadocs)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
     </xs:complexType>
    </xs:element>
    <xs:element name="COUNTER">
     <xs:complexType>
      <xs:attribute name="bypass_bundling" type="xs:string">
       <xs:annotation>
        <xs:documentation>Bypasses message bundling if true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="timeout" type="xs:string">
       <xs:annotation>
        <xs:documentation>Request timeouts (in ms). If the timeout elapses, a Timeout (runtime) exception will be thrown</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="reconciliation_timeout" type="xs:string">
       <xs:annotation>
        <xs:documentation>Number of milliseconds to wait for reconciliation responses from all current members</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="num_backups" type="xs:string">
       <xs:annotation>
        <xs:documentation>Number of backup coordinators. Modifications are asynchronously sent to all backup coordinators</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="stats" type="xs:string">
       <xs:annotation>
        <xs:documentation>Determines whether to collect statistics (and expose them via JMX). Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="ergonomics" type="xs:string">
       <xs:annotation>
        <xs:documentation>Enables ergonomics: dynamically find the best values for properties at runtime</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="name" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different name if needed so we can have multiple instances of it in the same stack (also change ID)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="id" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different ID if needed so we can have multiple instances of it in the same stack</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="level" type="xs:string">
       <xs:annotation>
        <xs:documentation>Sets the logger level (see javadocs)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
     </xs:complexType>
    </xs:element>
    <xs:element name="TCP">
     <xs:complexType>
      <xs:attribute name="reaper_interval" type="xs:string">
       <xs:annotation>
        <xs:documentation>Reaper interval in msec. Default is 0 (no reaping)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="conn_expire_time" type="xs:string">
       <xs:annotation>
        <xs:documentation>Max time connection can be idle before being reaped (in ms)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="use_send_queues" type="xs:string">
       <xs:annotation>
        <xs:documentation>Should separate send queues be used for each connection</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="send_queue_size" type="xs:string">
       <xs:annotation>
        <xs:documentation>Max number of messages in a send queue</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="recv_buf_size" type="xs:string">
       <xs:annotation>
        <xs:documentation>Receiver buffer size in bytes</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="send_buf_size" type="xs:string">
       <xs:annotation>
        <xs:documentation>Send buffer size in bytes</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="sock_conn_timeout" type="xs:string">
       <xs:annotation>
        <xs:documentation>Max time allowed for a socket creation in connection table</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="peer_addr_read_timeout" type="xs:string">
       <xs:annotation>
        <xs:documentation>Max time to block on reading of peer address</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="tcp_nodelay" type="xs:string">
       <xs:annotation>
        <xs:documentation>Should TCP no delay flag be turned on</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="linger" type="xs:string">
       <xs:annotation>
        <xs:documentation>SO_LINGER in msec. Default of -1 disables it</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="client_bind_addr" type="xs:string">
       <xs:annotation>
        <xs:documentation>The address of a local network interface which should be used by client sockets to bind to. The following special values are also recognized: GLOBAL, SITE_LOCAL, LINK_LOCAL and NON_LOOPBACK</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="client_bind_port" type="xs:string">
       <xs:annotation>
        <xs:documentation>The local port a client socket should bind to. If 0, an ephemeral port will be picked.</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="defer_client_bind_addr" type="xs:string">
       <xs:annotation>
        <xs:documentation>If true, client sockets will not explicitly bind to bind_addr but will defer to the native socket</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="bind_addr" type="xs:string">
       <xs:annotation>
        <xs:documentation>The bind address which should be used by this transport. The following special values are also recognized: GLOBAL, SITE_LOCAL, LINK_LOCAL, NON_LOOPBACK, match-interface, match-host, match-address</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="external_addr" type="xs:string">
       <xs:annotation>
        <xs:documentation>Use "external_addr" if you have hosts on different networks, behind firewalls. On each firewall, set up a port forwarding rule (sometimes called "virtual server") to the local IP (e.g. 192.168.1.100) of the host then on each host, set "external_addr" TCP transport parameter to the external (public IP) address of the firewall.</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="external_port" type="xs:string">
       <xs:annotation>
        <xs:documentation>Used to map the internal port (bind_port) to an external port. Only used if &gt; 0</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="bind_interface" type="xs:string">
       <xs:annotation>
        <xs:documentation>The interface (NIC) which should be used by this transport</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="receive_on_all_interfaces" type="xs:string">
       <xs:annotation>
        <xs:documentation>If true, the transport should use all available interfaces to receive multicast messages</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="receive_interfaces" type="xs:string">
       <xs:annotation>
        <xs:documentation>Comma delimited list of interfaces (IP addresses or interface names) to receive multicasts on</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="logical_addr_cache_max_size" type="xs:string">
       <xs:annotation>
        <xs:documentation>Max number of elements in the logical address cache before eviction starts</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="logical_addr_cache_expiration" type="xs:string">
       <xs:annotation>
        <xs:documentation>Time (in ms) after which entries in the logical address cache marked as removable are removed</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="bind_port" type="xs:string">
       <xs:annotation>
        <xs:documentation>The port to which the transport binds. Default of 0 binds to any (ephemeral) port</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="port_range" type="xs:string">
       <xs:annotation>
        <xs:documentation>The range of valid ports, from bind_port to end_port. 0 only binds to bind_port and fails if taken</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="loopback" type="xs:string">
       <xs:annotation>
        <xs:documentation>Messages to self are looped back immediately if true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="discard_incompatible_packets" type="xs:string">
       <xs:annotation>
        <xs:documentation>Discard packets with a different version if true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="thread_naming_pattern" type="xs:string">
       <xs:annotation>
        <xs:documentation>Thread naming pattern for threads in this channel. Valid values are "pcl": "p": includes the thread name, e.g. "Incoming thread-1", "UDP ucast receiver", "c": includes the cluster name, e.g. "MyCluster", "l": includes the local address of the current member, e.g. "192.168.5.1:5678"</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="oob_thread_pool.enabled" type="xs:string">
       <xs:annotation>
        <xs:documentation>Switch for enabling thread pool for OOB messages. Default=true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="oob_thread_pool.queue_enabled" type="xs:string">
       <xs:annotation>
        <xs:documentation>Use queue to enqueue incoming OOB messages</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="oob_thread_pool.queue_max_size" type="xs:string">
       <xs:annotation>
        <xs:documentation>Maximum queue size for incoming OOB messages</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="oob_thread_pool.rejection_policy" type="xs:string">
       <xs:annotation>
        <xs:documentation>Thread rejection policy. Possible values are Abort, Discard, DiscardOldest and Run</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="thread_pool.enabled" type="xs:string">
       <xs:annotation>
        <xs:documentation>Switch for enabling thread pool for regular messages</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="thread_pool.queue_enabled" type="xs:string">
       <xs:annotation>
        <xs:documentation>Queue to enqueue incoming regular messages</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="thread_pool.queue_max_size" type="xs:string">
       <xs:annotation>
        <xs:documentation>Maximum queue size for incoming OOB messages</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="thread_pool.rejection_policy" type="xs:string">
       <xs:annotation>
        <xs:documentation>Thread rejection policy. Possible values are Abort, Discard, DiscardOldest and Run</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="internal_thread_pool.enabled" type="xs:string">
       <xs:annotation>
        <xs:documentation>Switch for enabling thread pool for internal messages</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="internal_thread_pool.min_threads" type="xs:string">
       <xs:annotation>
        <xs:documentation>Minimum thread pool size for the internal thread pool</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="internal_thread_pool.max_threads" type="xs:string">
       <xs:annotation>
        <xs:documentation>Maximum thread pool size for the internal thread pool</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="internal_thread_pool.keep_alive_time" type="xs:string">
       <xs:annotation>
        <xs:documentation>Timeout in ms to remove idle threads from the internal pool</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="internal_thread_pool.queue_enabled" type="xs:string">
       <xs:annotation>
        <xs:documentation>Queue to enqueue incoming internal messages</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="internal_thread_pool.queue_max_size" type="xs:string">
       <xs:annotation>
        <xs:documentation>Maximum queue size for incoming internal messages</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="internal_thread_pool.rejection_policy" type="xs:string">
       <xs:annotation>
        <xs:documentation>Thread rejection policy. Possible values are Abort, Discard, DiscardOldest and Run</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="timer_type" type="xs:string">
       <xs:annotation>
        <xs:documentation>Type of timer to be used. Valid values are "old" (DefaultTimeScheduler, used up to 2.10), "new" or "new2" (TimeScheduler2), "new3" (TimeScheduler3) and "wheel". Note that this property might disappear in future releases, if one of the 3 timers is chosen as default timer</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="timer.queue_max_size" type="xs:string">
       <xs:annotation>
        <xs:documentation>Max number of elements on a timer queue</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="timer.rejection_policy" type="xs:string">
       <xs:annotation>
        <xs:documentation>Timer rejection policy. Possible values are Abort, Discard, DiscardOldest and Run</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="timer.wheel_size" type="xs:string">
       <xs:annotation>
        <xs:documentation>Number of ticks in the HashedTimingWheel timer. Only applicable if timer_type is "wheel"</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="timer.tick_time" type="xs:string">
       <xs:annotation>
        <xs:documentation>Tick duration in the HashedTimingWheel timer. Only applicable if timer_type is "wheel"</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="enable_bundling" type="xs:string">
       <xs:annotation>
        <xs:documentation>Enable bundling of smaller messages into bigger ones. Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="enable_unicast_bundling" type="xs:string">
       <xs:annotation>
        <xs:documentation>Enable bundling of smaller messages into bigger ones for unicast messages. Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="enable_batching" type="xs:string">
       <xs:annotation>
        <xs:documentation>Allows the transport to pass received message batches up as MessagesBatch instances (up(MessageBatch)), rather than individual messages. This flag will be removed in a future version when batching has been implemented by all protocols</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="enable_diagnostics" type="xs:string">
       <xs:annotation>
        <xs:documentation>Switch to enable diagnostic probing. Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="diagnostics_addr" type="xs:string">
       <xs:annotation>
        <xs:documentation>Address for diagnostic probing. Default is 224.0.75.75</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="diagnostics_bind_interfaces" type="xs:string">
       <xs:annotation>
        <xs:documentation>Comma delimited list of interfaces (IP addresses or interface names) that the diagnostics multicast socket should bind to</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="diagnostics_port" type="xs:string">
       <xs:annotation>
        <xs:documentation>Port for diagnostic probing. Default is 7500</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="diagnostics_ttl" type="xs:string">
       <xs:annotation>
        <xs:documentation>TTL of the diagnostics multicast socket</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="diagnostics_passcode" type="xs:string">
       <xs:annotation>
        <xs:documentation>Authorization passcode for diagnostics. If specified every probe query will be authorized</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="singleton_name" type="xs:string">
       <xs:annotation>
        <xs:documentation>If assigned enable this transport to be a singleton (shared) transport</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="log_discard_msgs" type="xs:string">
       <xs:annotation>
        <xs:documentation>whether or not warnings about messages from different groups are logged</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="log_discard_msgs_version" type="xs:string">
       <xs:annotation>
        <xs:documentation>whether or not warnings about messages from members with a different version are discarded</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="who_has_cache_timeout" type="xs:string">
       <xs:annotation>
        <xs:documentation>Timeout (in ms) to determine how long to wait until a request to fetch the physical address for a given logical address will be sent again. Subsequent requests for the same physical address will therefore be spaced at least who_has_cache_timeout ms apart</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="physical_addr_max_fetch_attempts" type="xs:string">
       <xs:annotation>
        <xs:documentation>Max number of attempts to fetch a physical address (when not in the cache) before giving up</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="suppress_time_different_version_warnings" type="xs:string">
       <xs:annotation>
        <xs:documentation>Time during which identical warnings about messages from a member with a different version will be suppressed. 0 disables this (every warning will be logged). Setting the log level to ERROR also disables this.</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="suppress_time_different_cluster_warnings" type="xs:string">
       <xs:annotation>
        <xs:documentation>Time during which identical warnings about messages from a member from a different cluster will be suppressed. 0 disables this (every warning will be logged). Setting the log level to ERROR also disables this.</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="bundler_type" type="xs:string">
       <xs:annotation>
        <xs:documentation>The type of bundler used. Has to be "old" or "new" (default)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="bundler_capacity" type="xs:string">
       <xs:annotation>
        <xs:documentation>The max number of elements in a bundler if the bundler supports size limitations</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="stats" type="xs:string">
       <xs:annotation>
        <xs:documentation>Determines whether to collect statistics (and expose them via JMX). Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="ergonomics" type="xs:string">
       <xs:annotation>
        <xs:documentation>Enables ergonomics: dynamically find the best values for properties at runtime</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="name" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different name if needed so we can have multiple instances of it in the same stack (also change ID)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="id" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different ID if needed so we can have multiple instances of it in the same stack</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="max_bundle_size" type="xs:string">
       <xs:annotation>
        <xs:documentation>Maximum number of bytes for messages to be queued until they are sent</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="max_bundle_timeout" type="xs:string">
       <xs:annotation>
        <xs:documentation>Max number of milliseconds until queued messages are sent</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="oob_thread_pool.keep_alive_time" type="xs:string">
       <xs:annotation>
        <xs:documentation>Timeout in ms to remove idle threads from the OOB pool</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="oob_thread_pool.min_threads" type="xs:string">
       <xs:annotation>
        <xs:documentation>Minimum thread pool size for the OOB thread pool</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="oob_thread_pool.max_threads" type="xs:string">
       <xs:annotation>
        <xs:documentation>Max thread pool size for the OOB thread pool</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="thread_pool.min_threads" type="xs:string">
       <xs:annotation>
        <xs:documentation>Minimum thread pool size for the regular thread pool</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="thread_pool.max_threads" type="xs:string">
       <xs:annotation>
        <xs:documentation>Maximum thread pool size for the regular thread pool</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="thread_pool.keep_alive_time" type="xs:string">
       <xs:annotation>
        <xs:documentation>Timeout in milliseconds to remove idle thread from regular pool</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="timer.min_threads" type="xs:string">
       <xs:annotation>
        <xs:documentation>Minimum thread pool size for the timer thread pool</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="timer.max_threads" type="xs:string">
       <xs:annotation>
        <xs:documentation>Max thread pool size for the timer thread pool</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="timer.keep_alive_time" type="xs:string">
       <xs:annotation>
        <xs:documentation>Timeout in ms to remove idle threads from the timer pool</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="level" type="xs:string">
       <xs:annotation>
        <xs:documentation>Sets the logger level (see javadocs)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
     </xs:complexType>
    </xs:element>
    <xs:element name="EXAMPLE">
     <xs:complexType>
      <xs:attribute name="stats" type="xs:string">
       <xs:annotation>
        <xs:documentation>Determines whether to collect statistics (and expose them via JMX). Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="ergonomics" type="xs:string">
       <xs:annotation>
        <xs:documentation>Enables ergonomics: dynamically find the best values for properties at runtime</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="name" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different name if needed so we can have multiple instances of it in the same stack (also change ID)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="id" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different ID if needed so we can have multiple instances of it in the same stack</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="level" type="xs:string">
       <xs:annotation>
        <xs:documentation>Sets the logger level (see javadocs)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
     </xs:complexType>
    </xs:element>
    <xs:element name="UFC">
     <xs:complexType>
      <xs:attribute name="max_credits" type="xs:string">
       <xs:annotation>
        <xs:documentation>Max number of bytes to send per receiver until an ack must be received to proceed</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="max_block_time" type="xs:string">
       <xs:annotation>
        <xs:documentation>Max time (in milliseconds) to block. Default is 5000 msec</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="min_threshold" type="xs:string">
       <xs:annotation>
        <xs:documentation>The threshold (as a percentage of max_credits) at which a receiver sends more credits to a sender. Example: if max_credits is 1'000'000, and min_threshold 0.25, then we send ca. 250'000 credits to P once we've got only 250'000 credits left for P (we've received 750'000 bytes from P)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="min_credits" type="xs:string">
       <xs:annotation>
        <xs:documentation>Computed as max_credits x min_theshold unless explicitly set</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="ignore_synchronous_response" type="xs:string">
       <xs:annotation>
        <xs:documentation>Does not block a down message if it is a result of handling an up message in thesame thread. Fixes JGRP-928</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="stats" type="xs:string">
       <xs:annotation>
        <xs:documentation>Determines whether to collect statistics (and expose them via JMX). Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="ergonomics" type="xs:string">
       <xs:annotation>
        <xs:documentation>Enables ergonomics: dynamically find the best values for properties at runtime</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="name" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different name if needed so we can have multiple instances of it in the same stack (also change ID)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="id" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different ID if needed so we can have multiple instances of it in the same stack</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="max_block_times" type="xs:string">
       <xs:annotation>
        <xs:documentation>Max times to block for the listed messages sizes (Message.getLength()). Example: "1000:10,5000:30,10000:500"</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="level" type="xs:string">
       <xs:annotation>
        <xs:documentation>Sets the logger level (see javadocs)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
     </xs:complexType>
    </xs:element>
    <xs:element name="TCPGOSSIP">
     <xs:complexType>
      <xs:attribute name="sock_conn_timeout" type="xs:string">
       <xs:annotation>
        <xs:documentation>Max time for socket creation. Default is 1000 msec</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="sock_read_timeout" type="xs:string">
       <xs:annotation>
        <xs:documentation>Max time in milliseconds to block on a read. 0 blocks forever</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="reconnect_interval" type="xs:string">
       <xs:annotation>
        <xs:documentation>Interval (ms) by which a disconnected stub attempts to reconnect to the GossipRouter</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="timeout" type="xs:string">
       <xs:annotation>
        <xs:documentation>Timeout to wait for the initial members</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="num_initial_members" type="xs:string">
       <xs:annotation>
        <xs:documentation>Minimum number of initial members to get a response from</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="num_initial_srv_members" type="xs:string">
       <xs:annotation>
        <xs:documentation>Minimum number of server responses (PingData.isServer()=true). If this value is greater than 0, we'll ignore num_initial_members</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="break_on_coord_rsp" type="xs:string">
       <xs:annotation>
        <xs:documentation>Return from the discovery phase as soon as we have 1 coordinator response</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="return_entire_cache" type="xs:string">
       <xs:annotation>
        <xs:documentation>Whether or not to return the entire logical-physical address cache mappings on a discovery request, or not.</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="stagger_timeout" type="xs:string">
       <xs:annotation>
        <xs:documentation>If greater than 0, we'll wait a random number of milliseconds in range [0..stagger_timeout] before sending a discovery response. This prevents traffic spikes in large clusters when everyone sends their discovery response at the same time</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="force_sending_discovery_rsps" type="xs:string">
       <xs:annotation>
        <xs:documentation>Always sends a discovery response, no matter what</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="use_disk_cache" type="xs:string">
       <xs:annotation>
        <xs:documentation>If a persistent disk cache (PDC) is present, combine the discovery results with the contents of the disk cache before returning the results</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="stats" type="xs:string">
       <xs:annotation>
        <xs:documentation>Determines whether to collect statistics (and expose them via JMX). Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="ergonomics" type="xs:string">
       <xs:annotation>
        <xs:documentation>Enables ergonomics: dynamically find the best values for properties at runtime</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="name" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different name if needed so we can have multiple instances of it in the same stack (also change ID)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="id" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different ID if needed so we can have multiple instances of it in the same stack</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="initial_hosts" type="xs:string">
       <xs:annotation>
        <xs:documentation>Comma delimited list of hosts to be contacted for initial membership</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="level" type="xs:string">
       <xs:annotation>
        <xs:documentation>Sets the logger level (see javadocs)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
     </xs:complexType>
    </xs:element>
    <xs:element name="STATS">
     <xs:complexType>
      <xs:attribute name="stats" type="xs:string">
       <xs:annotation>
        <xs:documentation>Determines whether to collect statistics (and expose them via JMX). Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="ergonomics" type="xs:string">
       <xs:annotation>
        <xs:documentation>Enables ergonomics: dynamically find the best values for properties at runtime</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="name" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different name if needed so we can have multiple instances of it in the same stack (also change ID)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="id" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different ID if needed so we can have multiple instances of it in the same stack</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="level" type="xs:string">
       <xs:annotation>
        <xs:documentation>Sets the logger level (see javadocs)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
     </xs:complexType>
    </xs:element>
    <xs:element name="DUPL">
     <xs:complexType>
      <xs:attribute name="incoming_copies" type="xs:string">
       <xs:annotation>
        <xs:documentation>Number of copies of each incoming message (0=no copies)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="outgoing_copies" type="xs:string">
       <xs:annotation>
        <xs:documentation>Number of copies of each outgoing message (0=no copies)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="copy_unicast_msgs" type="xs:string">
       <xs:annotation>
        <xs:documentation>Whether or not to copy unicast messages</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="copy_multicast_msgs" type="xs:string">
       <xs:annotation>
        <xs:documentation>Whether or not to copy multicast messages</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="stats" type="xs:string">
       <xs:annotation>
        <xs:documentation>Determines whether to collect statistics (and expose them via JMX). Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="ergonomics" type="xs:string">
       <xs:annotation>
        <xs:documentation>Enables ergonomics: dynamically find the best values for properties at runtime</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="name" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different name if needed so we can have multiple instances of it in the same stack (also change ID)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="id" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different ID if needed so we can have multiple instances of it in the same stack</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="level" type="xs:string">
       <xs:annotation>
        <xs:documentation>Sets the logger level (see javadocs)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
     </xs:complexType>
    </xs:element>
    <xs:element name="HDRS">
     <xs:complexType>
      <xs:attribute name="stats" type="xs:string">
       <xs:annotation>
        <xs:documentation>Determines whether to collect statistics (and expose them via JMX). Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="ergonomics" type="xs:string">
       <xs:annotation>
        <xs:documentation>Enables ergonomics: dynamically find the best values for properties at runtime</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="name" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different name if needed so we can have multiple instances of it in the same stack (also change ID)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="id" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different ID if needed so we can have multiple instances of it in the same stack</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="level" type="xs:string">
       <xs:annotation>
        <xs:documentation>Sets the logger level (see javadocs)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
     </xs:complexType>
    </xs:element>
    <xs:element name="SCOPE">
     <xs:complexType>
      <xs:attribute name="thread_naming_pattern" type="xs:string">
       <xs:annotation>
        <xs:documentation>Thread naming pattern for threads in this channel. Default is cl</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="expiration_time" type="xs:string">
       <xs:annotation>
        <xs:documentation>Time in milliseconds after which an expired scope will get removed. An expired scope is one to which no messages have been added in max_expiration_time milliseconds. 0 never expires scopes</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="expiration_interval" type="xs:string">
       <xs:annotation>
        <xs:documentation>Interval in milliseconds at which the expiry task tries to remove expired scopes</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="stats" type="xs:string">
       <xs:annotation>
        <xs:documentation>Determines whether to collect statistics (and expose them via JMX). Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="ergonomics" type="xs:string">
       <xs:annotation>
        <xs:documentation>Enables ergonomics: dynamically find the best values for properties at runtime</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="name" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different name if needed so we can have multiple instances of it in the same stack (also change ID)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="id" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different ID if needed so we can have multiple instances of it in the same stack</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="thread_pool.min_threads" type="xs:string">
       <xs:annotation>
        <xs:documentation>Minimum thread pool size for the regular thread pool</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="thread_pool.max_threads" type="xs:string">
       <xs:annotation>
        <xs:documentation>Maximum thread pool size for the regular thread pool</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="thread_pool.keep_alive_time" type="xs:string">
       <xs:annotation>
        <xs:documentation>Timeout in milliseconds to remove idle thread from regular pool</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="level" type="xs:string">
       <xs:annotation>
        <xs:documentation>Sets the logger level (see javadocs)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
     </xs:complexType>
    </xs:element>
    <xs:element name="FRAG2">
     <xs:complexType>
      <xs:attribute name="frag_size" type="xs:string">
       <xs:annotation>
        <xs:documentation>The max number of bytes in a message. Larger messages will be fragmented</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="stats" type="xs:string">
       <xs:annotation>
        <xs:documentation>Determines whether to collect statistics (and expose them via JMX). Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="ergonomics" type="xs:string">
       <xs:annotation>
        <xs:documentation>Enables ergonomics: dynamically find the best values for properties at runtime</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="name" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different name if needed so we can have multiple instances of it in the same stack (also change ID)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="id" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different ID if needed so we can have multiple instances of it in the same stack</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="level" type="xs:string">
       <xs:annotation>
        <xs:documentation>Sets the logger level (see javadocs)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
     </xs:complexType>
    </xs:element>
    <xs:element name="COMPRESS">
     <xs:complexType>
      <xs:attribute name="compression_level" type="xs:string">
       <xs:annotation>
        <xs:documentation>Compression level (from java.util.zip.Deflater) (0=no compression, 1=best speed, 9=best compression). Default is 9</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="min_size" type="xs:string">
       <xs:annotation>
        <xs:documentation>Minimal payload size of a message (in bytes) for compression to kick in. Default is 500 bytes</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="pool_size" type="xs:string">
       <xs:annotation>
        <xs:documentation>Number of inflaters/deflaters for concurrent processing. Default is 2 </xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="stats" type="xs:string">
       <xs:annotation>
        <xs:documentation>Determines whether to collect statistics (and expose them via JMX). Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="ergonomics" type="xs:string">
       <xs:annotation>
        <xs:documentation>Enables ergonomics: dynamically find the best values for properties at runtime</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="name" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different name if needed so we can have multiple instances of it in the same stack (also change ID)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="id" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different ID if needed so we can have multiple instances of it in the same stack</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="level" type="xs:string">
       <xs:annotation>
        <xs:documentation>Sets the logger level (see javadocs)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
     </xs:complexType>
    </xs:element>
    <xs:element name="MERGE2">
     <xs:complexType>
      <xs:attribute name="min_interval" type="xs:string">
       <xs:annotation>
        <xs:documentation>Minimum time in ms between runs to discover other clusters</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="max_interval" type="xs:string">
       <xs:annotation>
        <xs:documentation>Maximum time in ms between runs to discover other clusters</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="inconsistent_view_threshold" type="xs:string">
       <xs:annotation>
        <xs:documentation>Number of inconsistent  views with only 1 coord after a MERGE event is sent up</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="merge_fast" type="xs:string">
       <xs:annotation>
        <xs:documentation>When receiving a multicast message, checks if the sender is member of the cluster. If not, initiates a merge. Generates a lot of traffic for large clusters when there is a lot of merging</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="merge_fast_delay" type="xs:string">
       <xs:annotation>
        <xs:documentation>The delay (in milliseconds) after which a merge fast execution is started</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="stats" type="xs:string">
       <xs:annotation>
        <xs:documentation>Determines whether to collect statistics (and expose them via JMX). Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="ergonomics" type="xs:string">
       <xs:annotation>
        <xs:documentation>Enables ergonomics: dynamically find the best values for properties at runtime</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="name" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different name if needed so we can have multiple instances of it in the same stack (also change ID)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="id" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different ID if needed so we can have multiple instances of it in the same stack</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="level" type="xs:string">
       <xs:annotation>
        <xs:documentation>Sets the logger level (see javadocs)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
     </xs:complexType>
    </xs:element>
    <xs:element name="DAISYCHAIN">
     <xs:complexType>
      <xs:attribute name="loopback" type="xs:string">
       <xs:annotation>
        <xs:documentation>Loop back multicast messages</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="forward_queue_size" type="xs:string">
       <xs:annotation>
        <xs:documentation>The number of messages in the forward queue. This queue is used to host messages that need to be forwarded by us on behalf of our neighbor</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="send_queue_size" type="xs:string">
       <xs:annotation>
        <xs:documentation>The number of messages in the send queue. This queue is used to host messages that need to be sent</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="stats" type="xs:string">
       <xs:annotation>
        <xs:documentation>Determines whether to collect statistics (and expose them via JMX). Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="ergonomics" type="xs:string">
       <xs:annotation>
        <xs:documentation>Enables ergonomics: dynamically find the best values for properties at runtime</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="name" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different name if needed so we can have multiple instances of it in the same stack (also change ID)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="id" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different ID if needed so we can have multiple instances of it in the same stack</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="level" type="xs:string">
       <xs:annotation>
        <xs:documentation>Sets the logger level (see javadocs)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
     </xs:complexType>
    </xs:element>
    <xs:element name="CENTRAL_EXECUTOR">
     <xs:complexType>
      <xs:attribute name="num_backups" type="xs:string">
       <xs:annotation>
        <xs:documentation>Number of backups to the coordinator.  Queue State gets replicated to these nodes as well</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="bypass_bundling" type="xs:string">
       <xs:annotation>
        <xs:documentation>bypasses message bundling if set</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="stats" type="xs:string">
       <xs:annotation>
        <xs:documentation>Determines whether to collect statistics (and expose them via JMX). Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="ergonomics" type="xs:string">
       <xs:annotation>
        <xs:documentation>Enables ergonomics: dynamically find the best values for properties at runtime</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="name" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different name if needed so we can have multiple instances of it in the same stack (also change ID)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="id" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different ID if needed so we can have multiple instances of it in the same stack</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="level" type="xs:string">
       <xs:annotation>
        <xs:documentation>Sets the logger level (see javadocs)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
     </xs:complexType>
    </xs:element>
    <xs:element name="SHARED_LOOPBACK">
     <xs:complexType>
      <xs:attribute name="bind_addr" type="xs:string">
       <xs:annotation>
        <xs:documentation>The bind address which should be used by this transport. The following special values are also recognized: GLOBAL, SITE_LOCAL, LINK_LOCAL, NON_LOOPBACK, match-interface, match-host, match-address</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="external_addr" type="xs:string">
       <xs:annotation>
        <xs:documentation>Use "external_addr" if you have hosts on different networks, behind firewalls. On each firewall, set up a port forwarding rule (sometimes called "virtual server") to the local IP (e.g. 192.168.1.100) of the host then on each host, set "external_addr" TCP transport parameter to the external (public IP) address of the firewall.</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="external_port" type="xs:string">
       <xs:annotation>
        <xs:documentation>Used to map the internal port (bind_port) to an external port. Only used if &gt; 0</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="bind_interface" type="xs:string">
       <xs:annotation>
        <xs:documentation>The interface (NIC) which should be used by this transport</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="receive_on_all_interfaces" type="xs:string">
       <xs:annotation>
        <xs:documentation>If true, the transport should use all available interfaces to receive multicast messages</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="receive_interfaces" type="xs:string">
       <xs:annotation>
        <xs:documentation>Comma delimited list of interfaces (IP addresses or interface names) to receive multicasts on</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="logical_addr_cache_max_size" type="xs:string">
       <xs:annotation>
        <xs:documentation>Max number of elements in the logical address cache before eviction starts</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="logical_addr_cache_expiration" type="xs:string">
       <xs:annotation>
        <xs:documentation>Time (in ms) after which entries in the logical address cache marked as removable are removed</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="bind_port" type="xs:string">
       <xs:annotation>
        <xs:documentation>The port to which the transport binds. Default of 0 binds to any (ephemeral) port</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="port_range" type="xs:string">
       <xs:annotation>
        <xs:documentation>The range of valid ports, from bind_port to end_port. 0 only binds to bind_port and fails if taken</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="loopback" type="xs:string">
       <xs:annotation>
        <xs:documentation>Messages to self are looped back immediately if true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="discard_incompatible_packets" type="xs:string">
       <xs:annotation>
        <xs:documentation>Discard packets with a different version if true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="thread_naming_pattern" type="xs:string">
       <xs:annotation>
        <xs:documentation>Thread naming pattern for threads in this channel. Valid values are "pcl": "p": includes the thread name, e.g. "Incoming thread-1", "UDP ucast receiver", "c": includes the cluster name, e.g. "MyCluster", "l": includes the local address of the current member, e.g. "192.168.5.1:5678"</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="oob_thread_pool.enabled" type="xs:string">
       <xs:annotation>
        <xs:documentation>Switch for enabling thread pool for OOB messages. Default=true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="oob_thread_pool.queue_enabled" type="xs:string">
       <xs:annotation>
        <xs:documentation>Use queue to enqueue incoming OOB messages</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="oob_thread_pool.queue_max_size" type="xs:string">
       <xs:annotation>
        <xs:documentation>Maximum queue size for incoming OOB messages</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="oob_thread_pool.rejection_policy" type="xs:string">
       <xs:annotation>
        <xs:documentation>Thread rejection policy. Possible values are Abort, Discard, DiscardOldest and Run</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="thread_pool.enabled" type="xs:string">
       <xs:annotation>
        <xs:documentation>Switch for enabling thread pool for regular messages</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="thread_pool.queue_enabled" type="xs:string">
       <xs:annotation>
        <xs:documentation>Queue to enqueue incoming regular messages</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="thread_pool.queue_max_size" type="xs:string">
       <xs:annotation>
        <xs:documentation>Maximum queue size for incoming OOB messages</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="thread_pool.rejection_policy" type="xs:string">
       <xs:annotation>
        <xs:documentation>Thread rejection policy. Possible values are Abort, Discard, DiscardOldest and Run</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="internal_thread_pool.enabled" type="xs:string">
       <xs:annotation>
        <xs:documentation>Switch for enabling thread pool for internal messages</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="internal_thread_pool.min_threads" type="xs:string">
       <xs:annotation>
        <xs:documentation>Minimum thread pool size for the internal thread pool</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="internal_thread_pool.max_threads" type="xs:string">
       <xs:annotation>
        <xs:documentation>Maximum thread pool size for the internal thread pool</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="internal_thread_pool.keep_alive_time" type="xs:string">
       <xs:annotation>
        <xs:documentation>Timeout in ms to remove idle threads from the internal pool</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="internal_thread_pool.queue_enabled" type="xs:string">
       <xs:annotation>
        <xs:documentation>Queue to enqueue incoming internal messages</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="internal_thread_pool.queue_max_size" type="xs:string">
       <xs:annotation>
        <xs:documentation>Maximum queue size for incoming internal messages</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="internal_thread_pool.rejection_policy" type="xs:string">
       <xs:annotation>
        <xs:documentation>Thread rejection policy. Possible values are Abort, Discard, DiscardOldest and Run</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="timer_type" type="xs:string">
       <xs:annotation>
        <xs:documentation>Type of timer to be used. Valid values are "old" (DefaultTimeScheduler, used up to 2.10), "new" or "new2" (TimeScheduler2), "new3" (TimeScheduler3) and "wheel". Note that this property might disappear in future releases, if one of the 3 timers is chosen as default timer</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="timer.queue_max_size" type="xs:string">
       <xs:annotation>
        <xs:documentation>Max number of elements on a timer queue</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="timer.rejection_policy" type="xs:string">
       <xs:annotation>
        <xs:documentation>Timer rejection policy. Possible values are Abort, Discard, DiscardOldest and Run</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="timer.wheel_size" type="xs:string">
       <xs:annotation>
        <xs:documentation>Number of ticks in the HashedTimingWheel timer. Only applicable if timer_type is "wheel"</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="timer.tick_time" type="xs:string">
       <xs:annotation>
        <xs:documentation>Tick duration in the HashedTimingWheel timer. Only applicable if timer_type is "wheel"</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="enable_bundling" type="xs:string">
       <xs:annotation>
        <xs:documentation>Enable bundling of smaller messages into bigger ones. Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="enable_unicast_bundling" type="xs:string">
       <xs:annotation>
        <xs:documentation>Enable bundling of smaller messages into bigger ones for unicast messages. Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="enable_batching" type="xs:string">
       <xs:annotation>
        <xs:documentation>Allows the transport to pass received message batches up as MessagesBatch instances (up(MessageBatch)), rather than individual messages. This flag will be removed in a future version when batching has been implemented by all protocols</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="enable_diagnostics" type="xs:string">
       <xs:annotation>
        <xs:documentation>Switch to enable diagnostic probing. Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="diagnostics_addr" type="xs:string">
       <xs:annotation>
        <xs:documentation>Address for diagnostic probing. Default is 224.0.75.75</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="diagnostics_bind_interfaces" type="xs:string">
       <xs:annotation>
        <xs:documentation>Comma delimited list of interfaces (IP addresses or interface names) that the diagnostics multicast socket should bind to</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="diagnostics_port" type="xs:string">
       <xs:annotation>
        <xs:documentation>Port for diagnostic probing. Default is 7500</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="diagnostics_ttl" type="xs:string">
       <xs:annotation>
        <xs:documentation>TTL of the diagnostics multicast socket</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="diagnostics_passcode" type="xs:string">
       <xs:annotation>
        <xs:documentation>Authorization passcode for diagnostics. If specified every probe query will be authorized</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="singleton_name" type="xs:string">
       <xs:annotation>
        <xs:documentation>If assigned enable this transport to be a singleton (shared) transport</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="log_discard_msgs" type="xs:string">
       <xs:annotation>
        <xs:documentation>whether or not warnings about messages from different groups are logged</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="log_discard_msgs_version" type="xs:string">
       <xs:annotation>
        <xs:documentation>whether or not warnings about messages from members with a different version are discarded</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="who_has_cache_timeout" type="xs:string">
       <xs:annotation>
        <xs:documentation>Timeout (in ms) to determine how long to wait until a request to fetch the physical address for a given logical address will be sent again. Subsequent requests for the same physical address will therefore be spaced at least who_has_cache_timeout ms apart</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="physical_addr_max_fetch_attempts" type="xs:string">
       <xs:annotation>
        <xs:documentation>Max number of attempts to fetch a physical address (when not in the cache) before giving up</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="suppress_time_different_version_warnings" type="xs:string">
       <xs:annotation>
        <xs:documentation>Time during which identical warnings about messages from a member with a different version will be suppressed. 0 disables this (every warning will be logged). Setting the log level to ERROR also disables this.</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="suppress_time_different_cluster_warnings" type="xs:string">
       <xs:annotation>
        <xs:documentation>Time during which identical warnings about messages from a member from a different cluster will be suppressed. 0 disables this (every warning will be logged). Setting the log level to ERROR also disables this.</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="bundler_type" type="xs:string">
       <xs:annotation>
        <xs:documentation>The type of bundler used. Has to be "old" or "new" (default)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="bundler_capacity" type="xs:string">
       <xs:annotation>
        <xs:documentation>The max number of elements in a bundler if the bundler supports size limitations</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="stats" type="xs:string">
       <xs:annotation>
        <xs:documentation>Determines whether to collect statistics (and expose them via JMX). Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="ergonomics" type="xs:string">
       <xs:annotation>
        <xs:documentation>Enables ergonomics: dynamically find the best values for properties at runtime</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="name" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different name if needed so we can have multiple instances of it in the same stack (also change ID)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="id" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different ID if needed so we can have multiple instances of it in the same stack</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="max_bundle_size" type="xs:string">
       <xs:annotation>
        <xs:documentation>Maximum number of bytes for messages to be queued until they are sent</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="max_bundle_timeout" type="xs:string">
       <xs:annotation>
        <xs:documentation>Max number of milliseconds until queued messages are sent</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="oob_thread_pool.keep_alive_time" type="xs:string">
       <xs:annotation>
        <xs:documentation>Timeout in ms to remove idle threads from the OOB pool</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="oob_thread_pool.min_threads" type="xs:string">
       <xs:annotation>
        <xs:documentation>Minimum thread pool size for the OOB thread pool</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="oob_thread_pool.max_threads" type="xs:string">
       <xs:annotation>
        <xs:documentation>Max thread pool size for the OOB thread pool</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="thread_pool.min_threads" type="xs:string">
       <xs:annotation>
        <xs:documentation>Minimum thread pool size for the regular thread pool</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="thread_pool.max_threads" type="xs:string">
       <xs:annotation>
        <xs:documentation>Maximum thread pool size for the regular thread pool</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="thread_pool.keep_alive_time" type="xs:string">
       <xs:annotation>
        <xs:documentation>Timeout in milliseconds to remove idle thread from regular pool</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="timer.min_threads" type="xs:string">
       <xs:annotation>
        <xs:documentation>Minimum thread pool size for the timer thread pool</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="timer.max_threads" type="xs:string">
       <xs:annotation>
        <xs:documentation>Max thread pool size for the timer thread pool</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="timer.keep_alive_time" type="xs:string">
       <xs:annotation>
        <xs:documentation>Timeout in ms to remove idle threads from the timer pool</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="level" type="xs:string">
       <xs:annotation>
        <xs:documentation>Sets the logger level (see javadocs)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
     </xs:complexType>
    </xs:element>
    <xs:element name="PDC">
     <xs:complexType>
      <xs:attribute name="cache_dir" type="xs:string">
       <xs:annotation>
        <xs:documentation>The absolute path of the directory for the disk cache. The mappings will be stored as individual files in this directory</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="stats" type="xs:string">
       <xs:annotation>
        <xs:documentation>Determines whether to collect statistics (and expose them via JMX). Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="ergonomics" type="xs:string">
       <xs:annotation>
        <xs:documentation>Enables ergonomics: dynamically find the best values for properties at runtime</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="name" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different name if needed so we can have multiple instances of it in the same stack (also change ID)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="id" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different ID if needed so we can have multiple instances of it in the same stack</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="level" type="xs:string">
       <xs:annotation>
        <xs:documentation>Sets the logger level (see javadocs)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
     </xs:complexType>
    </xs:element>
    <xs:element name="FD_PING">
     <xs:complexType>
      <xs:attribute name="cmd" type="xs:string">
       <xs:annotation>
        <xs:documentation>Command (script or executable) to ping a host: a return value of 0 means success, anything else is a failure. Default is ping</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="verbose" type="xs:string">
       <xs:annotation>
        <xs:documentation>Write the stdout of the command to the log. Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="timeout" type="xs:string">
       <xs:annotation>
        <xs:documentation>Timeout to suspect a node P if neither a heartbeat nor data were received from P.</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="max_tries" type="xs:string">
       <xs:annotation>
        <xs:documentation>Number of times to send an are-you-alive message</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="msg_counts_as_heartbeat" type="xs:string">
       <xs:annotation>
        <xs:documentation>Treat messages received from members as heartbeats. Note that this means we're updating a value in a hashmap every time a message is passing up the stack through FD, which is costly.</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="stats" type="xs:string">
       <xs:annotation>
        <xs:documentation>Determines whether to collect statistics (and expose them via JMX). Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="ergonomics" type="xs:string">
       <xs:annotation>
        <xs:documentation>Enables ergonomics: dynamically find the best values for properties at runtime</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="name" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different name if needed so we can have multiple instances of it in the same stack (also change ID)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="id" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different ID if needed so we can have multiple instances of it in the same stack</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="level" type="xs:string">
       <xs:annotation>
        <xs:documentation>Sets the logger level (see javadocs)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
     </xs:complexType>
    </xs:element>
    <xs:element name="FRAG">
     <xs:complexType>
      <xs:attribute name="frag_size" type="xs:string">
       <xs:annotation>
        <xs:documentation>The max number of bytes in a message. Larger messages will be fragmented. Default is 8192 bytes</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="stats" type="xs:string">
       <xs:annotation>
        <xs:documentation>Determines whether to collect statistics (and expose them via JMX). Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="ergonomics" type="xs:string">
       <xs:annotation>
        <xs:documentation>Enables ergonomics: dynamically find the best values for properties at runtime</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="name" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different name if needed so we can have multiple instances of it in the same stack (also change ID)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="id" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different ID if needed so we can have multiple instances of it in the same stack</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="level" type="xs:string">
       <xs:annotation>
        <xs:documentation>Sets the logger level (see javadocs)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
     </xs:complexType>
    </xs:element>
    <xs:element name="FD_SOCK">
     <xs:complexType>
      <xs:attribute name="bind_addr" type="xs:string">
       <xs:annotation>
        <xs:documentation>The NIC on which the ServerSocket should listen on. The following special values are also recognized: GLOBAL, SITE_LOCAL, LINK_LOCAL and NON_LOOPBACK</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="external_addr" type="xs:string">
       <xs:annotation>
        <xs:documentation>Use "external_addr" if you have hosts on different networks, behind firewalls. On each firewall, set up a port forwarding rule (sometimes called "virtual server") to the local IP (e.g. 192.168.1.100) of the host then on each host, set "external_addr" TCP transport parameter to the external (public IP) address of the firewall.</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="external_port" type="xs:string">
       <xs:annotation>
        <xs:documentation>Used to map the internal port (bind_port) to an external port. Only used if &gt; 0</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="bind_interface" type="xs:string">
       <xs:annotation>
        <xs:documentation>The interface (NIC) which should be used by this transport</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="get_cache_timeout" type="xs:string">
       <xs:annotation>
        <xs:documentation>Timeout for getting socket cache from coordinator. Default is 1000 msec</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="suspect_msg_interval" type="xs:string">
       <xs:annotation>
        <xs:documentation>Interval for broadcasting suspect messages. Default is 5000 msec</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="num_tries" type="xs:string">
       <xs:annotation>
        <xs:documentation>Number of attempts coordinator is solicited for socket cache until we give up. Default is 3</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="start_port" type="xs:string">
       <xs:annotation>
        <xs:documentation>Start port for server socket. Default value of 0 picks a random port</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="client_bind_port" type="xs:string">
       <xs:annotation>
        <xs:documentation>Start port for client socket. Default value of 0 picks a random port</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="port_range" type="xs:string">
       <xs:annotation>
        <xs:documentation>Number of ports to probe for start_port and client_bind_port</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="keep_alive" type="xs:string">
       <xs:annotation>
        <xs:documentation>Whether to use KEEP_ALIVE on the ping socket or not. Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="sock_conn_timeout" type="xs:string">
       <xs:annotation>
        <xs:documentation>Max time in millis to wait for ping Socket.connect() to return</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="stats" type="xs:string">
       <xs:annotation>
        <xs:documentation>Determines whether to collect statistics (and expose them via JMX). Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="ergonomics" type="xs:string">
       <xs:annotation>
        <xs:documentation>Enables ergonomics: dynamically find the best values for properties at runtime</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="name" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different name if needed so we can have multiple instances of it in the same stack (also change ID)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="id" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different ID if needed so we can have multiple instances of it in the same stack</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="level" type="xs:string">
       <xs:annotation>
        <xs:documentation>Sets the logger level (see javadocs)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
     </xs:complexType>
    </xs:element>
    <xs:element name="MPING">
     <xs:complexType>
      <xs:attribute name="bind_addr" type="xs:string">
       <xs:annotation>
        <xs:documentation>Bind address for multicast socket. The following special values are also recognized: GLOBAL, SITE_LOCAL, LINK_LOCAL and NON_LOOPBACK</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="bind_interface" type="xs:string">
       <xs:annotation>
        <xs:documentation>The interface (NIC) which should be used by this transport</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="ip_ttl" type="xs:string">
       <xs:annotation>
        <xs:documentation>Time to live for discovery packets. Default is 8</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="mcast_addr" type="xs:string">
       <xs:annotation>
        <xs:documentation>Multicast address to be used for discovery</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="mcast_port" type="xs:string">
       <xs:annotation>
        <xs:documentation>Multicast port for discovery packets. Default is 7555</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="receive_on_all_interfaces" type="xs:string">
       <xs:annotation>
        <xs:documentation>If true, the transport should use all available interfaces to receive multicast messages. Default is false</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="receive_interfaces" type="xs:string">
       <xs:annotation>
        <xs:documentation>List of interfaces to receive multicasts on</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="send_on_all_interfaces" type="xs:string">
       <xs:annotation>
        <xs:documentation>Whether send messages are sent on all interfaces. Default is false</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="send_interfaces" type="xs:string">
       <xs:annotation>
        <xs:documentation>List of interfaces to send multicasts on</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="timeout" type="xs:string">
       <xs:annotation>
        <xs:documentation>Timeout to wait for the initial members</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="num_initial_members" type="xs:string">
       <xs:annotation>
        <xs:documentation>Minimum number of initial members to get a response from</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="num_initial_srv_members" type="xs:string">
       <xs:annotation>
        <xs:documentation>Minimum number of server responses (PingData.isServer()=true). If this value is greater than 0, we'll ignore num_initial_members</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="break_on_coord_rsp" type="xs:string">
       <xs:annotation>
        <xs:documentation>Return from the discovery phase as soon as we have 1 coordinator response</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="return_entire_cache" type="xs:string">
       <xs:annotation>
        <xs:documentation>Whether or not to return the entire logical-physical address cache mappings on a discovery request, or not.</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="stagger_timeout" type="xs:string">
       <xs:annotation>
        <xs:documentation>If greater than 0, we'll wait a random number of milliseconds in range [0..stagger_timeout] before sending a discovery response. This prevents traffic spikes in large clusters when everyone sends their discovery response at the same time</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="force_sending_discovery_rsps" type="xs:string">
       <xs:annotation>
        <xs:documentation>Always sends a discovery response, no matter what</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="use_disk_cache" type="xs:string">
       <xs:annotation>
        <xs:documentation>If a persistent disk cache (PDC) is present, combine the discovery results with the contents of the disk cache before returning the results</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="stats" type="xs:string">
       <xs:annotation>
        <xs:documentation>Determines whether to collect statistics (and expose them via JMX). Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="ergonomics" type="xs:string">
       <xs:annotation>
        <xs:documentation>Enables ergonomics: dynamically find the best values for properties at runtime</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="name" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different name if needed so we can have multiple instances of it in the same stack (also change ID)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="id" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different ID if needed so we can have multiple instances of it in the same stack</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="level" type="xs:string">
       <xs:annotation>
        <xs:documentation>Sets the logger level (see javadocs)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
     </xs:complexType>
    </xs:element>
    <xs:element name="SIZE">
     <xs:complexType>
      <xs:attribute name="print_msg" type="xs:string">
       <xs:annotation>
        <xs:documentation/>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="raw_buffer" type="xs:string">
       <xs:annotation>
        <xs:documentation/>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="min_size" type="xs:string">
       <xs:annotation>
        <xs:documentation/>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="stats" type="xs:string">
       <xs:annotation>
        <xs:documentation>Determines whether to collect statistics (and expose them via JMX). Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="ergonomics" type="xs:string">
       <xs:annotation>
        <xs:documentation>Enables ergonomics: dynamically find the best values for properties at runtime</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="name" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different name if needed so we can have multiple instances of it in the same stack (also change ID)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="id" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different ID if needed so we can have multiple instances of it in the same stack</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="level" type="xs:string">
       <xs:annotation>
        <xs:documentation>Sets the logger level (see javadocs)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
     </xs:complexType>
    </xs:element>
    <xs:element name="UNICAST2">
     <xs:complexType>
      <xs:attribute name="exponential_backoff" type="xs:string">
       <xs:annotation>
        <xs:documentation>The first value (in milliseconds) to use in the exponential backoff. Enabled if greater than 0</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="max_msg_batch_size" type="xs:string">
       <xs:annotation>
        <xs:documentation>Max number of messages to be removed from a NakReceiverWindow. This property might get removed anytime, so don't use it !</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="max_bytes" type="xs:string">
       <xs:annotation>
        <xs:documentation>Max number of bytes before a stability message is sent to the sender</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="stable_interval" type="xs:string">
       <xs:annotation>
        <xs:documentation>Max number of milliseconds before a stability message is sent to the sender(s)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="max_stable_msgs" type="xs:string">
       <xs:annotation>
        <xs:documentation>Max number of STABLE messages sent for the same highest_received seqno. A value &lt; 1 is invalid</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="xmit_table_num_rows" type="xs:string">
       <xs:annotation>
        <xs:documentation>Number of rows of the matrix in the retransmission table (only for experts)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="xmit_table_msgs_per_row" type="xs:string">
       <xs:annotation>
        <xs:documentation>Number of elements of a row of the matrix in the retransmission table (only for experts). The capacity of the matrix is xmit_table_num_rows * xmit_table_msgs_per_row</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="xmit_table_resize_factor" type="xs:string">
       <xs:annotation>
        <xs:documentation>Resize factor of the matrix in the retransmission table (only for experts)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="xmit_table_max_compaction_time" type="xs:string">
       <xs:annotation>
        <xs:documentation>Number of milliseconds after which the matrix in the retransmission table is compacted (only for experts)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="xmit_table_automatic_purging" type="xs:string">
       <xs:annotation>
        <xs:documentation>If enabled, the removal of a message from the retransmission table causes an automatic purge (only for experts)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="use_range_based_retransmitter" type="xs:string">
       <xs:annotation>
        <xs:documentation>Whether to use the old retransmitter which retransmits individual messages or the new one which uses ranges of retransmitted messages. Default is true. Note that this property will be removed in 3.0; it is only used to switch back to the old (and proven) retransmitter mechanism if issues occur</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="log_not_found_msgs" type="xs:string">
       <xs:annotation>
        <xs:documentation>If true, trashes warnings about retransmission messages not found in the xmit_table (used for testing)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="conn_expiry_timeout" type="xs:string">
       <xs:annotation>
        <xs:documentation>Time (in milliseconds) after which an idle incoming or outgoing connection is closed. The connection will get re-established when used again. 0 disables connection reaping</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="xmit_interval" type="xs:string">
       <xs:annotation>
        <xs:documentation>Interval (in milliseconds) at which missing messages (from all retransmit buffers) are retransmitted</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="stats" type="xs:string">
       <xs:annotation>
        <xs:documentation>Determines whether to collect statistics (and expose them via JMX). Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="ergonomics" type="xs:string">
       <xs:annotation>
        <xs:documentation>Enables ergonomics: dynamically find the best values for properties at runtime</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="name" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different name if needed so we can have multiple instances of it in the same stack (also change ID)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="id" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different ID if needed so we can have multiple instances of it in the same stack</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="timeout" type="xs:string">
       <xs:annotation>
        <xs:documentation>list of timeouts</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="max_retransmit_time" type="xs:string">
       <xs:annotation>
        <xs:documentation>Max number of milliseconds we try to retransmit a message to any given member. After that, the connection is removed. Any new connection to that member will start with seqno #1 again. 0 disables this</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="level" type="xs:string">
       <xs:annotation>
        <xs:documentation>Sets the logger level (see javadocs)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
     </xs:complexType>
    </xs:element>
    <xs:element name="FD_ALL">
     <xs:complexType>
      <xs:attribute name="interval" type="xs:string">
       <xs:annotation>
        <xs:documentation>Interval at which a HEARTBEAT is sent to the cluster</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="timeout" type="xs:string">
       <xs:annotation>
        <xs:documentation>Timeout after which a node P is suspected if neither a heartbeat nor data were received from P</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="timeout_check_interval" type="xs:string">
       <xs:annotation>
        <xs:documentation>Interval at which the HEARTBEAT timeouts are checked</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="msg_counts_as_heartbeat" type="xs:string">
       <xs:annotation>
        <xs:documentation>Treat messages received from members as heartbeats. Note that this means we're updating a value in a hashmap every time a message is passing up the stack through FD_ALL, which is costly. Default is false</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="stats" type="xs:string">
       <xs:annotation>
        <xs:documentation>Determines whether to collect statistics (and expose them via JMX). Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="ergonomics" type="xs:string">
       <xs:annotation>
        <xs:documentation>Enables ergonomics: dynamically find the best values for properties at runtime</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="name" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different name if needed so we can have multiple instances of it in the same stack (also change ID)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="id" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different ID if needed so we can have multiple instances of it in the same stack</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="level" type="xs:string">
       <xs:annotation>
        <xs:documentation>Sets the logger level (see javadocs)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
     </xs:complexType>
    </xs:element>
    <xs:element name="FD">
     <xs:complexType>
      <xs:attribute name="timeout" type="xs:string">
       <xs:annotation>
        <xs:documentation>Timeout to suspect a node P if neither a heartbeat nor data were received from P.</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="max_tries" type="xs:string">
       <xs:annotation>
        <xs:documentation>Number of times to send an are-you-alive message</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="msg_counts_as_heartbeat" type="xs:string">
       <xs:annotation>
        <xs:documentation>Treat messages received from members as heartbeats. Note that this means we're updating a value in a hashmap every time a message is passing up the stack through FD, which is costly.</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="stats" type="xs:string">
       <xs:annotation>
        <xs:documentation>Determines whether to collect statistics (and expose them via JMX). Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="ergonomics" type="xs:string">
       <xs:annotation>
        <xs:documentation>Enables ergonomics: dynamically find the best values for properties at runtime</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="name" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different name if needed so we can have multiple instances of it in the same stack (also change ID)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="id" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different ID if needed so we can have multiple instances of it in the same stack</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="level" type="xs:string">
       <xs:annotation>
        <xs:documentation>Sets the logger level (see javadocs)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
     </xs:complexType>
    </xs:element>
    <xs:element name="TCPPING">
     <xs:complexType>
      <xs:attribute name="port_range" type="xs:string">
       <xs:annotation>
        <xs:documentation>Number of additional ports to be probed for membership. A port_range of 0 does not probe additional ports. Example: initial_hosts=A[7800] port_range=0 probes A:7800, port_range=1 probes A:7800 and A:7801</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="initial_hosts" type="xs:string">
       <xs:annotation>
        <xs:documentation>Comma delimited list of hosts to be contacted for initial membership</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="max_dynamic_hosts" type="xs:string">
       <xs:annotation>
        <xs:documentation>max number of hosts to keep beyond the ones in initial_hosts</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="timeout" type="xs:string">
       <xs:annotation>
        <xs:documentation>Timeout to wait for the initial members</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="num_initial_members" type="xs:string">
       <xs:annotation>
        <xs:documentation>Minimum number of initial members to get a response from</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="num_initial_srv_members" type="xs:string">
       <xs:annotation>
        <xs:documentation>Minimum number of server responses (PingData.isServer()=true). If this value is greater than 0, we'll ignore num_initial_members</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="break_on_coord_rsp" type="xs:string">
       <xs:annotation>
        <xs:documentation>Return from the discovery phase as soon as we have 1 coordinator response</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="return_entire_cache" type="xs:string">
       <xs:annotation>
        <xs:documentation>Whether or not to return the entire logical-physical address cache mappings on a discovery request, or not.</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="stagger_timeout" type="xs:string">
       <xs:annotation>
        <xs:documentation>If greater than 0, we'll wait a random number of milliseconds in range [0..stagger_timeout] before sending a discovery response. This prevents traffic spikes in large clusters when everyone sends their discovery response at the same time</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="force_sending_discovery_rsps" type="xs:string">
       <xs:annotation>
        <xs:documentation>Always sends a discovery response, no matter what</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="use_disk_cache" type="xs:string">
       <xs:annotation>
        <xs:documentation>If a persistent disk cache (PDC) is present, combine the discovery results with the contents of the disk cache before returning the results</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="stats" type="xs:string">
       <xs:annotation>
        <xs:documentation>Determines whether to collect statistics (and expose them via JMX). Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="ergonomics" type="xs:string">
       <xs:annotation>
        <xs:documentation>Enables ergonomics: dynamically find the best values for properties at runtime</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="name" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different name if needed so we can have multiple instances of it in the same stack (also change ID)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="id" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different ID if needed so we can have multiple instances of it in the same stack</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="level" type="xs:string">
       <xs:annotation>
        <xs:documentation>Sets the logger level (see javadocs)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
     </xs:complexType>
    </xs:element>
    <xs:element name="UNICAST3">
     <xs:complexType>
      <xs:attribute name="max_msg_batch_size" type="xs:string">
       <xs:annotation>
        <xs:documentation>Max number of messages to be removed from a retransmit window. This property might get removed anytime, so don't use it !</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="conn_expiry_timeout" type="xs:string">
       <xs:annotation>
        <xs:documentation>Time (in milliseconds) after which an idle incoming or outgoing connection is closed. The connection will get re-established when used again. 0 disables connection reaping</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="conn_close_timeout" type="xs:string">
       <xs:annotation>
        <xs:documentation>Time (in ms) until a connection marked to be closed will get removed. 0 disables this</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="xmit_table_num_rows" type="xs:string">
       <xs:annotation>
        <xs:documentation>Number of rows of the matrix in the retransmission table (only for experts)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="xmit_table_msgs_per_row" type="xs:string">
       <xs:annotation>
        <xs:documentation>Number of elements of a row of the matrix in the retransmission table (only for experts). The capacity of the matrix is xmit_table_num_rows * xmit_table_msgs_per_row</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="xmit_table_resize_factor" type="xs:string">
       <xs:annotation>
        <xs:documentation>Resize factor of the matrix in the retransmission table (only for experts)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="xmit_table_max_compaction_time" type="xs:string">
       <xs:annotation>
        <xs:documentation>Number of milliseconds after which the matrix in the retransmission table is compacted (only for experts)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="xmit_interval" type="xs:string">
       <xs:annotation>
        <xs:documentation>Interval (in milliseconds) at which messages in the send windows are resent</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="log_not_found_msgs" type="xs:string">
       <xs:annotation>
        <xs:documentation>If true, trashes warnings about retransmission messages not found in the xmit_table (used for testing)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="ack_batches_immediately" type="xs:string">
       <xs:annotation>
        <xs:documentation>Send an ack for a batch immediately instead of using a delayed ack</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="ack_threshold" type="xs:string">
       <xs:annotation>
        <xs:documentation>Send an ack immediately when a batch of ack_threshold (or more) messages is received. Otherwise send delayed acks. If 1, ack single messages (similar to UNICAST)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="stats" type="xs:string">
       <xs:annotation>
        <xs:documentation>Determines whether to collect statistics (and expose them via JMX). Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="ergonomics" type="xs:string">
       <xs:annotation>
        <xs:documentation>Enables ergonomics: dynamically find the best values for properties at runtime</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="name" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different name if needed so we can have multiple instances of it in the same stack (also change ID)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="id" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different ID if needed so we can have multiple instances of it in the same stack</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="max_retransmit_time" type="xs:string">
       <xs:annotation>
        <xs:documentation>Max number of milliseconds we try to retransmit a message to any given member. After that, the connection is removed. Any new connection to that member will start with seqno #1 again. 0 disables this</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="level" type="xs:string">
       <xs:annotation>
        <xs:documentation>Sets the logger level (see javadocs)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
     </xs:complexType>
    </xs:element>
    <xs:element name="BPING">
     <xs:complexType>
      <xs:attribute name="dest" type="xs:string">
       <xs:annotation>
        <xs:documentation>Target address for broadcasts. This should be restricted to the local subnet, e.g. 192.168.1.255</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="bind_port" type="xs:string">
       <xs:annotation>
        <xs:documentation>Port for discovery packets</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="port_range" type="xs:string">
       <xs:annotation>
        <xs:documentation>Sends discovery packets to ports 8555 to (8555+port_range)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="timeout" type="xs:string">
       <xs:annotation>
        <xs:documentation>Timeout to wait for the initial members</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="num_initial_members" type="xs:string">
       <xs:annotation>
        <xs:documentation>Minimum number of initial members to get a response from</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="num_initial_srv_members" type="xs:string">
       <xs:annotation>
        <xs:documentation>Minimum number of server responses (PingData.isServer()=true). If this value is greater than 0, we'll ignore num_initial_members</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="break_on_coord_rsp" type="xs:string">
       <xs:annotation>
        <xs:documentation>Return from the discovery phase as soon as we have 1 coordinator response</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="return_entire_cache" type="xs:string">
       <xs:annotation>
        <xs:documentation>Whether or not to return the entire logical-physical address cache mappings on a discovery request, or not.</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="stagger_timeout" type="xs:string">
       <xs:annotation>
        <xs:documentation>If greater than 0, we'll wait a random number of milliseconds in range [0..stagger_timeout] before sending a discovery response. This prevents traffic spikes in large clusters when everyone sends their discovery response at the same time</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="force_sending_discovery_rsps" type="xs:string">
       <xs:annotation>
        <xs:documentation>Always sends a discovery response, no matter what</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="use_disk_cache" type="xs:string">
       <xs:annotation>
        <xs:documentation>If a persistent disk cache (PDC) is present, combine the discovery results with the contents of the disk cache before returning the results</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="stats" type="xs:string">
       <xs:annotation>
        <xs:documentation>Determines whether to collect statistics (and expose them via JMX). Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="ergonomics" type="xs:string">
       <xs:annotation>
        <xs:documentation>Enables ergonomics: dynamically find the best values for properties at runtime</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="name" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different name if needed so we can have multiple instances of it in the same stack (also change ID)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="id" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different ID if needed so we can have multiple instances of it in the same stack</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="level" type="xs:string">
       <xs:annotation>
        <xs:documentation>Sets the logger level (see javadocs)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
     </xs:complexType>
    </xs:element>
    <xs:element name="PEER_LOCK">
     <xs:complexType>
      <xs:attribute name="bypass_bundling" type="xs:string">
       <xs:annotation>
        <xs:documentation>bypasses message bundling if set</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="lock_striping_size" type="xs:string">
       <xs:annotation>
        <xs:documentation>Number of locks to be used for lock striping (for synchronized access to the server_lock entries)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="stats" type="xs:string">
       <xs:annotation>
        <xs:documentation>Determines whether to collect statistics (and expose them via JMX). Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="ergonomics" type="xs:string">
       <xs:annotation>
        <xs:documentation>Enables ergonomics: dynamically find the best values for properties at runtime</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="name" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different name if needed so we can have multiple instances of it in the same stack (also change ID)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="id" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different ID if needed so we can have multiple instances of it in the same stack</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="level" type="xs:string">
       <xs:annotation>
        <xs:documentation>Sets the logger level (see javadocs)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
     </xs:complexType>
    </xs:element>
    <xs:element name="SEQUENCER">
     <xs:complexType>
      <xs:attribute name="delivery_table_max_size" type="xs:string">
       <xs:annotation>
        <xs:documentation>Size of the set to store received seqnos (for duplicate checking)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="threshold" type="xs:string">
       <xs:annotation>
        <xs:documentation>Number of acks needed before going from ack-mode to normal mode. 0 disables this, which means that ack-mode is always on</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="stats" type="xs:string">
       <xs:annotation>
        <xs:documentation>Determines whether to collect statistics (and expose them via JMX). Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="ergonomics" type="xs:string">
       <xs:annotation>
        <xs:documentation>Enables ergonomics: dynamically find the best values for properties at runtime</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="name" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different name if needed so we can have multiple instances of it in the same stack (also change ID)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="id" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different ID if needed so we can have multiple instances of it in the same stack</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="level" type="xs:string">
       <xs:annotation>
        <xs:documentation>Sets the logger level (see javadocs)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
     </xs:complexType>
    </xs:element>
    <xs:element name="VERIFY_SUSPECT">
     <xs:complexType>
      <xs:attribute name="timeout" type="xs:string">
       <xs:annotation>
        <xs:documentation>Number of millisecs to wait for a response from a suspected member</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="num_msgs" type="xs:string">
       <xs:annotation>
        <xs:documentation>Number of verify heartbeats sent to a suspected member</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="use_icmp" type="xs:string">
       <xs:annotation>
        <xs:documentation>Use InetAddress.isReachable() to verify suspected member instead of regular messages</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="use_mcast_rsps" type="xs:string">
       <xs:annotation>
        <xs:documentation>Send the I_AM_NOT_DEAD message back as a multicast rather than as multiple unicasts (default is false)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="bind_addr" type="xs:string">
       <xs:annotation>
        <xs:documentation>Interface for ICMP pings. Used if use_icmp is true The following special values are also recognized: GLOBAL, SITE_LOCAL, LINK_LOCAL and NON_LOOPBACK</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="bind_interface" type="xs:string">
       <xs:annotation>
        <xs:documentation>The interface (NIC) which should be used by this transport</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="stats" type="xs:string">
       <xs:annotation>
        <xs:documentation>Determines whether to collect statistics (and expose them via JMX). Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="ergonomics" type="xs:string">
       <xs:annotation>
        <xs:documentation>Enables ergonomics: dynamically find the best values for properties at runtime</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="name" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different name if needed so we can have multiple instances of it in the same stack (also change ID)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="id" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different ID if needed so we can have multiple instances of it in the same stack</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="level" type="xs:string">
       <xs:annotation>
        <xs:documentation>Sets the logger level (see javadocs)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
     </xs:complexType>
    </xs:element>
    <xs:element name="TUNNEL">
     <xs:complexType>
      <xs:attribute name="reconnect_interval" type="xs:string">
       <xs:annotation>
        <xs:documentation>Interval in msec to attempt connecting back to router in case of torn connection. Default is 5000 msec</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="tcp_nodelay" type="xs:string">
       <xs:annotation>
        <xs:documentation>Should TCP no delay flag be turned on</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="bind_addr" type="xs:string">
       <xs:annotation>
        <xs:documentation>The bind address which should be used by this transport. The following special values are also recognized: GLOBAL, SITE_LOCAL, LINK_LOCAL, NON_LOOPBACK, match-interface, match-host, match-address</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="external_addr" type="xs:string">
       <xs:annotation>
        <xs:documentation>Use "external_addr" if you have hosts on different networks, behind firewalls. On each firewall, set up a port forwarding rule (sometimes called "virtual server") to the local IP (e.g. 192.168.1.100) of the host then on each host, set "external_addr" TCP transport parameter to the external (public IP) address of the firewall.</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="external_port" type="xs:string">
       <xs:annotation>
        <xs:documentation>Used to map the internal port (bind_port) to an external port. Only used if &gt; 0</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="bind_interface" type="xs:string">
       <xs:annotation>
        <xs:documentation>The interface (NIC) which should be used by this transport</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="receive_on_all_interfaces" type="xs:string">
       <xs:annotation>
        <xs:documentation>If true, the transport should use all available interfaces to receive multicast messages</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="receive_interfaces" type="xs:string">
       <xs:annotation>
        <xs:documentation>Comma delimited list of interfaces (IP addresses or interface names) to receive multicasts on</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="logical_addr_cache_max_size" type="xs:string">
       <xs:annotation>
        <xs:documentation>Max number of elements in the logical address cache before eviction starts</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="logical_addr_cache_expiration" type="xs:string">
       <xs:annotation>
        <xs:documentation>Time (in ms) after which entries in the logical address cache marked as removable are removed</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="bind_port" type="xs:string">
       <xs:annotation>
        <xs:documentation>The port to which the transport binds. Default of 0 binds to any (ephemeral) port</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="port_range" type="xs:string">
       <xs:annotation>
        <xs:documentation>The range of valid ports, from bind_port to end_port. 0 only binds to bind_port and fails if taken</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="loopback" type="xs:string">
       <xs:annotation>
        <xs:documentation>Messages to self are looped back immediately if true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="discard_incompatible_packets" type="xs:string">
       <xs:annotation>
        <xs:documentation>Discard packets with a different version if true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="thread_naming_pattern" type="xs:string">
       <xs:annotation>
        <xs:documentation>Thread naming pattern for threads in this channel. Valid values are "pcl": "p": includes the thread name, e.g. "Incoming thread-1", "UDP ucast receiver", "c": includes the cluster name, e.g. "MyCluster", "l": includes the local address of the current member, e.g. "192.168.5.1:5678"</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="oob_thread_pool.enabled" type="xs:string">
       <xs:annotation>
        <xs:documentation>Switch for enabling thread pool for OOB messages. Default=true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="oob_thread_pool.queue_enabled" type="xs:string">
       <xs:annotation>
        <xs:documentation>Use queue to enqueue incoming OOB messages</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="oob_thread_pool.queue_max_size" type="xs:string">
       <xs:annotation>
        <xs:documentation>Maximum queue size for incoming OOB messages</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="oob_thread_pool.rejection_policy" type="xs:string">
       <xs:annotation>
        <xs:documentation>Thread rejection policy. Possible values are Abort, Discard, DiscardOldest and Run</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="thread_pool.enabled" type="xs:string">
       <xs:annotation>
        <xs:documentation>Switch for enabling thread pool for regular messages</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="thread_pool.queue_enabled" type="xs:string">
       <xs:annotation>
        <xs:documentation>Queue to enqueue incoming regular messages</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="thread_pool.queue_max_size" type="xs:string">
       <xs:annotation>
        <xs:documentation>Maximum queue size for incoming OOB messages</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="thread_pool.rejection_policy" type="xs:string">
       <xs:annotation>
        <xs:documentation>Thread rejection policy. Possible values are Abort, Discard, DiscardOldest and Run</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="internal_thread_pool.enabled" type="xs:string">
       <xs:annotation>
        <xs:documentation>Switch for enabling thread pool for internal messages</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="internal_thread_pool.min_threads" type="xs:string">
       <xs:annotation>
        <xs:documentation>Minimum thread pool size for the internal thread pool</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="internal_thread_pool.max_threads" type="xs:string">
       <xs:annotation>
        <xs:documentation>Maximum thread pool size for the internal thread pool</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="internal_thread_pool.keep_alive_time" type="xs:string">
       <xs:annotation>
        <xs:documentation>Timeout in ms to remove idle threads from the internal pool</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="internal_thread_pool.queue_enabled" type="xs:string">
       <xs:annotation>
        <xs:documentation>Queue to enqueue incoming internal messages</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="internal_thread_pool.queue_max_size" type="xs:string">
       <xs:annotation>
        <xs:documentation>Maximum queue size for incoming internal messages</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="internal_thread_pool.rejection_policy" type="xs:string">
       <xs:annotation>
        <xs:documentation>Thread rejection policy. Possible values are Abort, Discard, DiscardOldest and Run</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="timer_type" type="xs:string">
       <xs:annotation>
        <xs:documentation>Type of timer to be used. Valid values are "old" (DefaultTimeScheduler, used up to 2.10), "new" or "new2" (TimeScheduler2), "new3" (TimeScheduler3) and "wheel". Note that this property might disappear in future releases, if one of the 3 timers is chosen as default timer</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="timer.queue_max_size" type="xs:string">
       <xs:annotation>
        <xs:documentation>Max number of elements on a timer queue</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="timer.rejection_policy" type="xs:string">
       <xs:annotation>
        <xs:documentation>Timer rejection policy. Possible values are Abort, Discard, DiscardOldest and Run</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="timer.wheel_size" type="xs:string">
       <xs:annotation>
        <xs:documentation>Number of ticks in the HashedTimingWheel timer. Only applicable if timer_type is "wheel"</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="timer.tick_time" type="xs:string">
       <xs:annotation>
        <xs:documentation>Tick duration in the HashedTimingWheel timer. Only applicable if timer_type is "wheel"</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="enable_bundling" type="xs:string">
       <xs:annotation>
        <xs:documentation>Enable bundling of smaller messages into bigger ones. Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="enable_unicast_bundling" type="xs:string">
       <xs:annotation>
        <xs:documentation>Enable bundling of smaller messages into bigger ones for unicast messages. Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="enable_batching" type="xs:string">
       <xs:annotation>
        <xs:documentation>Allows the transport to pass received message batches up as MessagesBatch instances (up(MessageBatch)), rather than individual messages. This flag will be removed in a future version when batching has been implemented by all protocols</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="enable_diagnostics" type="xs:string">
       <xs:annotation>
        <xs:documentation>Switch to enable diagnostic probing. Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="diagnostics_addr" type="xs:string">
       <xs:annotation>
        <xs:documentation>Address for diagnostic probing. Default is 224.0.75.75</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="diagnostics_bind_interfaces" type="xs:string">
       <xs:annotation>
        <xs:documentation>Comma delimited list of interfaces (IP addresses or interface names) that the diagnostics multicast socket should bind to</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="diagnostics_port" type="xs:string">
       <xs:annotation>
        <xs:documentation>Port for diagnostic probing. Default is 7500</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="diagnostics_ttl" type="xs:string">
       <xs:annotation>
        <xs:documentation>TTL of the diagnostics multicast socket</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="diagnostics_passcode" type="xs:string">
       <xs:annotation>
        <xs:documentation>Authorization passcode for diagnostics. If specified every probe query will be authorized</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="singleton_name" type="xs:string">
       <xs:annotation>
        <xs:documentation>If assigned enable this transport to be a singleton (shared) transport</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="log_discard_msgs" type="xs:string">
       <xs:annotation>
        <xs:documentation>whether or not warnings about messages from different groups are logged</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="log_discard_msgs_version" type="xs:string">
       <xs:annotation>
        <xs:documentation>whether or not warnings about messages from members with a different version are discarded</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="who_has_cache_timeout" type="xs:string">
       <xs:annotation>
        <xs:documentation>Timeout (in ms) to determine how long to wait until a request to fetch the physical address for a given logical address will be sent again. Subsequent requests for the same physical address will therefore be spaced at least who_has_cache_timeout ms apart</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="physical_addr_max_fetch_attempts" type="xs:string">
       <xs:annotation>
        <xs:documentation>Max number of attempts to fetch a physical address (when not in the cache) before giving up</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="suppress_time_different_version_warnings" type="xs:string">
       <xs:annotation>
        <xs:documentation>Time during which identical warnings about messages from a member with a different version will be suppressed. 0 disables this (every warning will be logged). Setting the log level to ERROR also disables this.</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="suppress_time_different_cluster_warnings" type="xs:string">
       <xs:annotation>
        <xs:documentation>Time during which identical warnings about messages from a member from a different cluster will be suppressed. 0 disables this (every warning will be logged). Setting the log level to ERROR also disables this.</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="bundler_type" type="xs:string">
       <xs:annotation>
        <xs:documentation>The type of bundler used. Has to be "old" or "new" (default)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="bundler_capacity" type="xs:string">
       <xs:annotation>
        <xs:documentation>The max number of elements in a bundler if the bundler supports size limitations</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="stats" type="xs:string">
       <xs:annotation>
        <xs:documentation>Determines whether to collect statistics (and expose them via JMX). Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="ergonomics" type="xs:string">
       <xs:annotation>
        <xs:documentation>Enables ergonomics: dynamically find the best values for properties at runtime</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="name" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different name if needed so we can have multiple instances of it in the same stack (also change ID)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="id" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different ID if needed so we can have multiple instances of it in the same stack</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="gossip_router_hosts" type="xs:string">
       <xs:annotation>
        <xs:documentation>A comma-separated list of GossipRouter hosts, e.g. HostA[12001],HostB[12001]</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="max_bundle_size" type="xs:string">
       <xs:annotation>
        <xs:documentation>Maximum number of bytes for messages to be queued until they are sent</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="max_bundle_timeout" type="xs:string">
       <xs:annotation>
        <xs:documentation>Max number of milliseconds until queued messages are sent</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="oob_thread_pool.keep_alive_time" type="xs:string">
       <xs:annotation>
        <xs:documentation>Timeout in ms to remove idle threads from the OOB pool</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="oob_thread_pool.min_threads" type="xs:string">
       <xs:annotation>
        <xs:documentation>Minimum thread pool size for the OOB thread pool</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="oob_thread_pool.max_threads" type="xs:string">
       <xs:annotation>
        <xs:documentation>Max thread pool size for the OOB thread pool</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="thread_pool.min_threads" type="xs:string">
       <xs:annotation>
        <xs:documentation>Minimum thread pool size for the regular thread pool</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="thread_pool.max_threads" type="xs:string">
       <xs:annotation>
        <xs:documentation>Maximum thread pool size for the regular thread pool</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="thread_pool.keep_alive_time" type="xs:string">
       <xs:annotation>
        <xs:documentation>Timeout in milliseconds to remove idle thread from regular pool</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="timer.min_threads" type="xs:string">
       <xs:annotation>
        <xs:documentation>Minimum thread pool size for the timer thread pool</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="timer.max_threads" type="xs:string">
       <xs:annotation>
        <xs:documentation>Max thread pool size for the timer thread pool</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="timer.keep_alive_time" type="xs:string">
       <xs:annotation>
        <xs:documentation>Timeout in ms to remove idle threads from the timer pool</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="level" type="xs:string">
       <xs:annotation>
        <xs:documentation>Sets the logger level (see javadocs)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
     </xs:complexType>
    </xs:element>
    <xs:element name="UDP">
     <xs:complexType>
      <xs:attribute name="tos" type="xs:string">
       <xs:annotation>
        <xs:documentation>Traffic class for sending unicast and multicast datagrams. Default is 8</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="mcast_addr" type="xs:string">
       <xs:annotation>
        <xs:documentation>The multicast address used for sending and receiving packets. Default is 228.8.8.8</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="mcast_port" type="xs:string">
       <xs:annotation>
        <xs:documentation>The multicast port used for sending and receiving packets. Default is 7600</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="ip_mcast" type="xs:string">
       <xs:annotation>
        <xs:documentation>Multicast toggle. If false multiple unicast datagrams are sent instead of one multicast. Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="ip_ttl" type="xs:string">
       <xs:annotation>
        <xs:documentation>The time-to-live (TTL) for multicast datagram packets. Default is 8</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="mcast_send_buf_size" type="xs:string">
       <xs:annotation>
        <xs:documentation>Send buffer size of the multicast datagram socket. Default is 100'000 bytes</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="mcast_recv_buf_size" type="xs:string">
       <xs:annotation>
        <xs:documentation>Receive buffer size of the multicast datagram socket. Default is 500'000 bytes</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="ucast_send_buf_size" type="xs:string">
       <xs:annotation>
        <xs:documentation>Send buffer size of the unicast datagram socket. Default is 100'000 bytes</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="ucast_recv_buf_size" type="xs:string">
       <xs:annotation>
        <xs:documentation>Receive buffer size of the unicast datagram socket. Default is 64'000 bytes</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="disable_loopback" type="xs:string">
       <xs:annotation>
        <xs:documentation>If true, disables IP_MULTICAST_LOOP on the MulticastSocket (for sending and receiving of multicast packets). IP multicast packets send on a host P will therefore not be received by anyone on P. Use with caution.</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="bind_addr" type="xs:string">
       <xs:annotation>
        <xs:documentation>The bind address which should be used by this transport. The following special values are also recognized: GLOBAL, SITE_LOCAL, LINK_LOCAL, NON_LOOPBACK, match-interface, match-host, match-address</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="external_addr" type="xs:string">
       <xs:annotation>
        <xs:documentation>Use "external_addr" if you have hosts on different networks, behind firewalls. On each firewall, set up a port forwarding rule (sometimes called "virtual server") to the local IP (e.g. 192.168.1.100) of the host then on each host, set "external_addr" TCP transport parameter to the external (public IP) address of the firewall.</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="external_port" type="xs:string">
       <xs:annotation>
        <xs:documentation>Used to map the internal port (bind_port) to an external port. Only used if &gt; 0</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="bind_interface" type="xs:string">
       <xs:annotation>
        <xs:documentation>The interface (NIC) which should be used by this transport</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="receive_on_all_interfaces" type="xs:string">
       <xs:annotation>
        <xs:documentation>If true, the transport should use all available interfaces to receive multicast messages</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="receive_interfaces" type="xs:string">
       <xs:annotation>
        <xs:documentation>Comma delimited list of interfaces (IP addresses or interface names) to receive multicasts on</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="logical_addr_cache_max_size" type="xs:string">
       <xs:annotation>
        <xs:documentation>Max number of elements in the logical address cache before eviction starts</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="logical_addr_cache_expiration" type="xs:string">
       <xs:annotation>
        <xs:documentation>Time (in ms) after which entries in the logical address cache marked as removable are removed</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="bind_port" type="xs:string">
       <xs:annotation>
        <xs:documentation>The port to which the transport binds. Default of 0 binds to any (ephemeral) port</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="port_range" type="xs:string">
       <xs:annotation>
        <xs:documentation>The range of valid ports, from bind_port to end_port. 0 only binds to bind_port and fails if taken</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="loopback" type="xs:string">
       <xs:annotation>
        <xs:documentation>Messages to self are looped back immediately if true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="discard_incompatible_packets" type="xs:string">
       <xs:annotation>
        <xs:documentation>Discard packets with a different version if true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="thread_naming_pattern" type="xs:string">
       <xs:annotation>
        <xs:documentation>Thread naming pattern for threads in this channel. Valid values are "pcl": "p": includes the thread name, e.g. "Incoming thread-1", "UDP ucast receiver", "c": includes the cluster name, e.g. "MyCluster", "l": includes the local address of the current member, e.g. "192.168.5.1:5678"</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="oob_thread_pool.enabled" type="xs:string">
       <xs:annotation>
        <xs:documentation>Switch for enabling thread pool for OOB messages. Default=true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="oob_thread_pool.queue_enabled" type="xs:string">
       <xs:annotation>
        <xs:documentation>Use queue to enqueue incoming OOB messages</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="oob_thread_pool.queue_max_size" type="xs:string">
       <xs:annotation>
        <xs:documentation>Maximum queue size for incoming OOB messages</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="oob_thread_pool.rejection_policy" type="xs:string">
       <xs:annotation>
        <xs:documentation>Thread rejection policy. Possible values are Abort, Discard, DiscardOldest and Run</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="thread_pool.enabled" type="xs:string">
       <xs:annotation>
        <xs:documentation>Switch for enabling thread pool for regular messages</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="thread_pool.queue_enabled" type="xs:string">
       <xs:annotation>
        <xs:documentation>Queue to enqueue incoming regular messages</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="thread_pool.queue_max_size" type="xs:string">
       <xs:annotation>
        <xs:documentation>Maximum queue size for incoming OOB messages</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="thread_pool.rejection_policy" type="xs:string">
       <xs:annotation>
        <xs:documentation>Thread rejection policy. Possible values are Abort, Discard, DiscardOldest and Run</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="internal_thread_pool.enabled" type="xs:string">
       <xs:annotation>
        <xs:documentation>Switch for enabling thread pool for internal messages</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="internal_thread_pool.min_threads" type="xs:string">
       <xs:annotation>
        <xs:documentation>Minimum thread pool size for the internal thread pool</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="internal_thread_pool.max_threads" type="xs:string">
       <xs:annotation>
        <xs:documentation>Maximum thread pool size for the internal thread pool</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="internal_thread_pool.keep_alive_time" type="xs:string">
       <xs:annotation>
        <xs:documentation>Timeout in ms to remove idle threads from the internal pool</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="internal_thread_pool.queue_enabled" type="xs:string">
       <xs:annotation>
        <xs:documentation>Queue to enqueue incoming internal messages</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="internal_thread_pool.queue_max_size" type="xs:string">
       <xs:annotation>
        <xs:documentation>Maximum queue size for incoming internal messages</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="internal_thread_pool.rejection_policy" type="xs:string">
       <xs:annotation>
        <xs:documentation>Thread rejection policy. Possible values are Abort, Discard, DiscardOldest and Run</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="timer_type" type="xs:string">
       <xs:annotation>
        <xs:documentation>Type of timer to be used. Valid values are "old" (DefaultTimeScheduler, used up to 2.10), "new" or "new2" (TimeScheduler2), "new3" (TimeScheduler3) and "wheel". Note that this property might disappear in future releases, if one of the 3 timers is chosen as default timer</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="timer.queue_max_size" type="xs:string">
       <xs:annotation>
        <xs:documentation>Max number of elements on a timer queue</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="timer.rejection_policy" type="xs:string">
       <xs:annotation>
        <xs:documentation>Timer rejection policy. Possible values are Abort, Discard, DiscardOldest and Run</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="timer.wheel_size" type="xs:string">
       <xs:annotation>
        <xs:documentation>Number of ticks in the HashedTimingWheel timer. Only applicable if timer_type is "wheel"</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="timer.tick_time" type="xs:string">
       <xs:annotation>
        <xs:documentation>Tick duration in the HashedTimingWheel timer. Only applicable if timer_type is "wheel"</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="enable_bundling" type="xs:string">
       <xs:annotation>
        <xs:documentation>Enable bundling of smaller messages into bigger ones. Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="enable_unicast_bundling" type="xs:string">
       <xs:annotation>
        <xs:documentation>Enable bundling of smaller messages into bigger ones for unicast messages. Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="enable_batching" type="xs:string">
       <xs:annotation>
        <xs:documentation>Allows the transport to pass received message batches up as MessagesBatch instances (up(MessageBatch)), rather than individual messages. This flag will be removed in a future version when batching has been implemented by all protocols</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="enable_diagnostics" type="xs:string">
       <xs:annotation>
        <xs:documentation>Switch to enable diagnostic probing. Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="diagnostics_addr" type="xs:string">
       <xs:annotation>
        <xs:documentation>Address for diagnostic probing. Default is 224.0.75.75</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="diagnostics_bind_interfaces" type="xs:string">
       <xs:annotation>
        <xs:documentation>Comma delimited list of interfaces (IP addresses or interface names) that the diagnostics multicast socket should bind to</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="diagnostics_port" type="xs:string">
       <xs:annotation>
        <xs:documentation>Port for diagnostic probing. Default is 7500</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="diagnostics_ttl" type="xs:string">
       <xs:annotation>
        <xs:documentation>TTL of the diagnostics multicast socket</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="diagnostics_passcode" type="xs:string">
       <xs:annotation>
        <xs:documentation>Authorization passcode for diagnostics. If specified every probe query will be authorized</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="singleton_name" type="xs:string">
       <xs:annotation>
        <xs:documentation>If assigned enable this transport to be a singleton (shared) transport</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="log_discard_msgs" type="xs:string">
       <xs:annotation>
        <xs:documentation>whether or not warnings about messages from different groups are logged</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="log_discard_msgs_version" type="xs:string">
       <xs:annotation>
        <xs:documentation>whether or not warnings about messages from members with a different version are discarded</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="who_has_cache_timeout" type="xs:string">
       <xs:annotation>
        <xs:documentation>Timeout (in ms) to determine how long to wait until a request to fetch the physical address for a given logical address will be sent again. Subsequent requests for the same physical address will therefore be spaced at least who_has_cache_timeout ms apart</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="physical_addr_max_fetch_attempts" type="xs:string">
       <xs:annotation>
        <xs:documentation>Max number of attempts to fetch a physical address (when not in the cache) before giving up</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="suppress_time_different_version_warnings" type="xs:string">
       <xs:annotation>
        <xs:documentation>Time during which identical warnings about messages from a member with a different version will be suppressed. 0 disables this (every warning will be logged). Setting the log level to ERROR also disables this.</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="suppress_time_different_cluster_warnings" type="xs:string">
       <xs:annotation>
        <xs:documentation>Time during which identical warnings about messages from a member from a different cluster will be suppressed. 0 disables this (every warning will be logged). Setting the log level to ERROR also disables this.</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="bundler_type" type="xs:string">
       <xs:annotation>
        <xs:documentation>The type of bundler used. Has to be "old" or "new" (default)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="bundler_capacity" type="xs:string">
       <xs:annotation>
        <xs:documentation>The max number of elements in a bundler if the bundler supports size limitations</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="stats" type="xs:string">
       <xs:annotation>
        <xs:documentation>Determines whether to collect statistics (and expose them via JMX). Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="ergonomics" type="xs:string">
       <xs:annotation>
        <xs:documentation>Enables ergonomics: dynamically find the best values for properties at runtime</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="name" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different name if needed so we can have multiple instances of it in the same stack (also change ID)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="id" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different ID if needed so we can have multiple instances of it in the same stack</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="max_bundle_size" type="xs:string">
       <xs:annotation>
        <xs:documentation>Maximum number of bytes for messages to be queued until they are sent</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="max_bundle_timeout" type="xs:string">
       <xs:annotation>
        <xs:documentation>Max number of milliseconds until queued messages are sent</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="oob_thread_pool.keep_alive_time" type="xs:string">
       <xs:annotation>
        <xs:documentation>Timeout in ms to remove idle threads from the OOB pool</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="oob_thread_pool.min_threads" type="xs:string">
       <xs:annotation>
        <xs:documentation>Minimum thread pool size for the OOB thread pool</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="oob_thread_pool.max_threads" type="xs:string">
       <xs:annotation>
        <xs:documentation>Max thread pool size for the OOB thread pool</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="thread_pool.min_threads" type="xs:string">
       <xs:annotation>
        <xs:documentation>Minimum thread pool size for the regular thread pool</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="thread_pool.max_threads" type="xs:string">
       <xs:annotation>
        <xs:documentation>Maximum thread pool size for the regular thread pool</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="thread_pool.keep_alive_time" type="xs:string">
       <xs:annotation>
        <xs:documentation>Timeout in milliseconds to remove idle thread from regular pool</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="timer.min_threads" type="xs:string">
       <xs:annotation>
        <xs:documentation>Minimum thread pool size for the timer thread pool</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="timer.max_threads" type="xs:string">
       <xs:annotation>
        <xs:documentation>Max thread pool size for the timer thread pool</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="timer.keep_alive_time" type="xs:string">
       <xs:annotation>
        <xs:documentation>Timeout in ms to remove idle threads from the timer pool</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="level" type="xs:string">
       <xs:annotation>
        <xs:documentation>Sets the logger level (see javadocs)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
     </xs:complexType>
    </xs:element>
    <xs:element name="pbcast.STATE">
     <xs:complexType>
      <xs:attribute name="buffer_size" type="xs:string">
       <xs:annotation>
        <xs:documentation>Size (in bytes) of the state transfer buffer</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="max_pool" type="xs:string">
       <xs:annotation>
        <xs:documentation>Maximum number of pool threads serving state requests</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="pool_thread_keep_alive" type="xs:string">
       <xs:annotation>
        <xs:documentation>Keep alive for pool threads serving state requests</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="stats" type="xs:string">
       <xs:annotation>
        <xs:documentation>Determines whether to collect statistics (and expose them via JMX). Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="ergonomics" type="xs:string">
       <xs:annotation>
        <xs:documentation>Enables ergonomics: dynamically find the best values for properties at runtime</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="name" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different name if needed so we can have multiple instances of it in the same stack (also change ID)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="id" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different ID if needed so we can have multiple instances of it in the same stack</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="level" type="xs:string">
       <xs:annotation>
        <xs:documentation>Sets the logger level (see javadocs)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
     </xs:complexType>
    </xs:element>
    <xs:element name="pbcast.NAKACK2">
     <xs:complexType>
      <xs:attribute name="max_msg_batch_size" type="xs:string">
       <xs:annotation>
        <xs:documentation>Max number of messages to be removed from a RingBuffer. This property might get removed anytime, so don't use it !</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="use_mcast_xmit" type="xs:string">
       <xs:annotation>
        <xs:documentation>Retransmit retransmit responses (messages) using multicast rather than unicast</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="use_mcast_xmit_req" type="xs:string">
       <xs:annotation>
        <xs:documentation>Use a multicast to request retransmission of missing messages</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="xmit_from_random_member" type="xs:string">
       <xs:annotation>
        <xs:documentation>Ask a random member for retransmission of a missing message. Default is false</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="discard_delivered_msgs" type="xs:string">
       <xs:annotation>
        <xs:documentation>Should messages delivered to application be discarded</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="max_rebroadcast_timeout" type="xs:string">
       <xs:annotation>
        <xs:documentation>Timeout to rebroadcast messages. Default is 2000 msec</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="print_stability_history_on_failed_xmit" type="xs:string">
       <xs:annotation>
        <xs:documentation>Should stability history be printed if we fail in retransmission. Default is false</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="log_discard_msgs" type="xs:string">
       <xs:annotation>
        <xs:documentation>discards warnings about promiscuous traffic</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="log_not_found_msgs" type="xs:string">
       <xs:annotation>
        <xs:documentation>If true, trashes warnings about retransmission messages not found in the xmit_table (used for testing)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="xmit_interval" type="xs:string">
       <xs:annotation>
        <xs:documentation>Interval (in milliseconds) at which missing messages (from all retransmit buffers) are retransmitted</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="xmit_table_num_rows" type="xs:string">
       <xs:annotation>
        <xs:documentation>Number of rows of the matrix in the retransmission table (only for experts)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="xmit_table_msgs_per_row" type="xs:string">
       <xs:annotation>
        <xs:documentation>Number of elements of a row of the matrix in the retransmission table (only for experts). The capacity of the matrix is xmit_table_num_rows * xmit_table_msgs_per_row</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="xmit_table_resize_factor" type="xs:string">
       <xs:annotation>
        <xs:documentation>Resize factor of the matrix in the retransmission table (only for experts)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="xmit_table_max_compaction_time" type="xs:string">
       <xs:annotation>
        <xs:documentation>Number of milliseconds after which the matrix in the retransmission table is compacted (only for experts)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="become_server_queue_size" type="xs:string">
       <xs:annotation>
        <xs:documentation>Size of the queue to hold messages received after creating the channel, but before being connected (is_server=false). After becoming the server, the messages in the queue are fed into up() and the queue is cleared. The motivation is to avoid retransmissions (see https://issues.jboss.org/browse/JGRP-1509 for details). 0 disables the queue.</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="suppress_time_non_member_warnings" type="xs:string">
       <xs:annotation>
        <xs:documentation>Time during which identical warnings about messages from a non member will be suppressed. 0 disables this (every warning will be logged). Setting the log level to ERROR also disables this.</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="stats" type="xs:string">
       <xs:annotation>
        <xs:documentation>Determines whether to collect statistics (and expose them via JMX). Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="ergonomics" type="xs:string">
       <xs:annotation>
        <xs:documentation>Enables ergonomics: dynamically find the best values for properties at runtime</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="name" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different name if needed so we can have multiple instances of it in the same stack (also change ID)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="id" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different ID if needed so we can have multiple instances of it in the same stack</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="level" type="xs:string">
       <xs:annotation>
        <xs:documentation>Sets the logger level (see javadocs)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
     </xs:complexType>
    </xs:element>
    <xs:element name="pbcast.STABLE">
     <xs:complexType>
      <xs:attribute name="desired_avg_gossip" type="xs:string">
       <xs:annotation>
        <xs:documentation>Average time to send a STABLE message</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="stability_delay" type="xs:string">
       <xs:annotation>
        <xs:documentation>Delay before stability message is sent</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="max_bytes" type="xs:string">
       <xs:annotation>
        <xs:documentation>Maximum number of bytes received in all messages before sending a STABLE message is triggered</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="cap" type="xs:string">
       <xs:annotation>
        <xs:documentation>Max percentage of the max heap (-Xmx) to be used for max_bytes. Only used if ergonomics is enabled. 0 disables setting max_bytes dynamically.</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="send_stable_msgs_to_coord_only" type="xs:string">
       <xs:annotation>
        <xs:documentation>Wether or not to send the STABLE messages to all members of the cluster, or to the current coordinator only. The latter reduces the number of STABLE messages, but also generates more work on the coordinator</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="stats" type="xs:string">
       <xs:annotation>
        <xs:documentation>Determines whether to collect statistics (and expose them via JMX). Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="ergonomics" type="xs:string">
       <xs:annotation>
        <xs:documentation>Enables ergonomics: dynamically find the best values for properties at runtime</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="name" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different name if needed so we can have multiple instances of it in the same stack (also change ID)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="id" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different ID if needed so we can have multiple instances of it in the same stack</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="level" type="xs:string">
       <xs:annotation>
        <xs:documentation>Sets the logger level (see javadocs)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
     </xs:complexType>
    </xs:element>
    <xs:element name="pbcast.NAKACK">
     <xs:complexType>
      <xs:attribute name="retransmit_timeout" type="xs:string">
       <xs:annotation>
        <xs:documentation>Timeout before requesting retransmissions</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="max_msg_batch_size" type="xs:string">
       <xs:annotation>
        <xs:documentation>Max number of messages to be removed from a NakReceiverWindow. This property might get removed anytime, so don't use it !</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="use_mcast_xmit" type="xs:string">
       <xs:annotation>
        <xs:documentation>Retransmit retransmit responses (messages) using multicast rather than unicast</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="use_mcast_xmit_req" type="xs:string">
       <xs:annotation>
        <xs:documentation>Use a multicast to request retransmission of missing messages</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="xmit_stagger_timeout" type="xs:string">
       <xs:annotation>
        <xs:documentation>Number of milliseconds to delay the sending of an XMIT request. We pick a random number in the range [1 .. xmit_req_stagger_timeout] and add this to the scheduling time of an XMIT request. When use_mcast_xmit is enabled, if a number of members drop messages from the same member, then chances are that, if staggering is enabled, somebody else already sent the XMIT request (via mcast) and we can cancel the XMIT request once we receive the missing messages. For unicast XMIT responses (use_mcast_xmit=false), we still have an advantage by not overwhelming the receiver with XMIT requests, all at the same time. 0 disabless staggering.</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="xmit_from_random_member" type="xs:string">
       <xs:annotation>
        <xs:documentation>Ask a random member for retransmission of a missing message. Default is false</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="exponential_backoff" type="xs:string">
       <xs:annotation>
        <xs:documentation>The first value (in milliseconds) to use in the exponential backoff. Enabled if greater than 0</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="use_range_based_retransmitter" type="xs:string">
       <xs:annotation>
        <xs:documentation>Whether to use the old retransmitter which retransmits individual messages or the new one which uses ranges of retransmitted messages. Default is true. Note that this property will be removed in 3.0; it is only used to switch back to the old (and proven) retransmitter mechanism if issues occur</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="discard_delivered_msgs" type="xs:string">
       <xs:annotation>
        <xs:documentation>Should messages delivered to application be discarded</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="max_rebroadcast_timeout" type="xs:string">
       <xs:annotation>
        <xs:documentation>Timeout to rebroadcast messages. Default is 2000 msec</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="print_stability_history_on_failed_xmit" type="xs:string">
       <xs:annotation>
        <xs:documentation>Should stability history be printed if we fail in retransmission. Default is false</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="log_discard_msgs" type="xs:string">
       <xs:annotation>
        <xs:documentation>discards warnings about promiscuous traffic</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="log_not_found_msgs" type="xs:string">
       <xs:annotation>
        <xs:documentation>If true, trashes warnings about retransmission messages not found in the xmit_table (used for testing)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="xmit_table_num_rows" type="xs:string">
       <xs:annotation>
        <xs:documentation>Number of rows of the matrix in the retransmission table (only for experts)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="xmit_table_msgs_per_row" type="xs:string">
       <xs:annotation>
        <xs:documentation>Number of elements of a row of the matrix in the retransmission table (only for experts). The capacity of the matrix is xmit_table_num_rows * xmit_table_msgs_per_row</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="xmit_table_resize_factor" type="xs:string">
       <xs:annotation>
        <xs:documentation>Resize factor of the matrix in the retransmission table (only for experts)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="xmit_table_max_compaction_time" type="xs:string">
       <xs:annotation>
        <xs:documentation>Number of milliseconds after which the matrix in the retransmission table is compacted (only for experts)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="become_server_queue_size" type="xs:string">
       <xs:annotation>
        <xs:documentation>Size of the queue to hold messages received after creating the channel, but before being connected (is_server=false). After becoming the server, the messages in the queue are fed into up() and the queue is cleared. The motivation is to avoid retransmissions (see https://issues.jboss.org/browse/JGRP-1509 for details). 0 disables the queue.</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="suppress_time_non_member_warnings" type="xs:string">
       <xs:annotation>
        <xs:documentation>Time during which identical warnings about messages from a non member will be suppressed. 0 disables this (every warning will be logged). Setting the log level to ERROR also disables this.</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="stats" type="xs:string">
       <xs:annotation>
        <xs:documentation>Determines whether to collect statistics (and expose them via JMX). Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="ergonomics" type="xs:string">
       <xs:annotation>
        <xs:documentation>Enables ergonomics: dynamically find the best values for properties at runtime</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="name" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different name if needed so we can have multiple instances of it in the same stack (also change ID)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="id" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different ID if needed so we can have multiple instances of it in the same stack</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="level" type="xs:string">
       <xs:annotation>
        <xs:documentation>Sets the logger level (see javadocs)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
     </xs:complexType>
    </xs:element>
    <xs:element name="pbcast.GMS">
     <xs:complexType>
      <xs:attribute name="join_timeout" type="xs:string">
       <xs:annotation>
        <xs:documentation>Join timeout</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="leave_timeout" type="xs:string">
       <xs:annotation>
        <xs:documentation>Leave timeout</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="merge_timeout" type="xs:string">
       <xs:annotation>
        <xs:documentation>Timeout (in ms) to complete merge</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="max_join_attempts" type="xs:string">
       <xs:annotation>
        <xs:documentation>Number of join attempts before we give up and become a singleton. Zero means 'never give up'.</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="print_local_addr" type="xs:string">
       <xs:annotation>
        <xs:documentation>Print local address of this member after connect. Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="print_physical_addrs" type="xs:string">
       <xs:annotation>
        <xs:documentation>Print physical address(es) on startup</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="handle_concurrent_startup" type="xs:string">
       <xs:annotation>
        <xs:documentation>Temporary switch. Default is true and should not be changed</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="view_bundling" type="xs:string">
       <xs:annotation>
        <xs:documentation>View bundling toggle</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="max_bundling_time" type="xs:string">
       <xs:annotation>
        <xs:documentation>Max view bundling timeout if view bundling is turned on. Default is 50 msec</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="num_prev_mbrs" type="xs:string">
       <xs:annotation>
        <xs:documentation>Max number of old members to keep in history. Default is 50</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="num_prev_views" type="xs:string">
       <xs:annotation>
        <xs:documentation>Number of views to store in history</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="view_ack_collection_timeout" type="xs:string">
       <xs:annotation>
        <xs:documentation>Time in ms to wait for all VIEW acks (0 == wait forever. Default is 2000 msec</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="resume_task_timeout" type="xs:string">
       <xs:annotation>
        <xs:documentation>Timeout to resume ViewHandler</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="use_flush_if_present" type="xs:string">
       <xs:annotation>
        <xs:documentation>Use flush for view changes. Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="log_collect_msgs" type="xs:string">
       <xs:annotation>
        <xs:documentation>Logs failures for collecting all view acks if true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="log_view_warnings" type="xs:string">
       <xs:annotation>
        <xs:documentation>Logs warnings for reception of views less than the current, and for views which don't include self</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="flush_invoker_class" type="xs:string">
       <xs:annotation>
        <xs:documentation/>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="stats" type="xs:string">
       <xs:annotation>
        <xs:documentation>Determines whether to collect statistics (and expose them via JMX). Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="ergonomics" type="xs:string">
       <xs:annotation>
        <xs:documentation>Enables ergonomics: dynamically find the best values for properties at runtime</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="name" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different name if needed so we can have multiple instances of it in the same stack (also change ID)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="id" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different ID if needed so we can have multiple instances of it in the same stack</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="level" type="xs:string">
       <xs:annotation>
        <xs:documentation>Sets the logger level (see javadocs)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
     </xs:complexType>
    </xs:element>
    <xs:element name="pbcast.STATE_TRANSFER">
     <xs:complexType>
      <xs:attribute name="stats" type="xs:string">
       <xs:annotation>
        <xs:documentation>Determines whether to collect statistics (and expose them via JMX). Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="ergonomics" type="xs:string">
       <xs:annotation>
        <xs:documentation>Enables ergonomics: dynamically find the best values for properties at runtime</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="name" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different name if needed so we can have multiple instances of it in the same stack (also change ID)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="id" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different ID if needed so we can have multiple instances of it in the same stack</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="level" type="xs:string">
       <xs:annotation>
        <xs:documentation>Sets the logger level (see javadocs)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
     </xs:complexType>
    </xs:element>
    <xs:element name="pbcast.STATE_SOCK">
     <xs:complexType>
      <xs:attribute name="bind_addr" type="xs:string">
       <xs:annotation>
        <xs:documentation>The interface (NIC) used to accept state requests. The following special values are also recognized: GLOBAL, SITE_LOCAL, LINK_LOCAL and NON_LOOPBACK</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="external_addr" type="xs:string">
       <xs:annotation>
        <xs:documentation>Use "external_addr" if you have hosts on different networks, behind firewalls. On each firewall, set up a port forwarding rule (sometimes called "virtual server") to the local IP (e.g. 192.168.1.100) of the host then on each host, set "external_addr" TCP transport parameter to the external (public IP) address of the firewall.</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="external_port" type="xs:string">
       <xs:annotation>
        <xs:documentation>Used to map the internal port (bind_port) to an external port. Only used if &gt; 0</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="bind_interface" type="xs:string">
       <xs:annotation>
        <xs:documentation>The interface (NIC) which should be used by this transport</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="bind_port" type="xs:string">
       <xs:annotation>
        <xs:documentation>The port listening for state requests. Default value of 0 binds to any (ephemeral) port</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="buffer_size" type="xs:string">
       <xs:annotation>
        <xs:documentation>Size (in bytes) of the state transfer buffer</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="max_pool" type="xs:string">
       <xs:annotation>
        <xs:documentation>Maximum number of pool threads serving state requests</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="pool_thread_keep_alive" type="xs:string">
       <xs:annotation>
        <xs:documentation>Keep alive for pool threads serving state requests</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="stats" type="xs:string">
       <xs:annotation>
        <xs:documentation>Determines whether to collect statistics (and expose them via JMX). Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="ergonomics" type="xs:string">
       <xs:annotation>
        <xs:documentation>Enables ergonomics: dynamically find the best values for properties at runtime</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="name" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different name if needed so we can have multiple instances of it in the same stack (also change ID)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="id" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different ID if needed so we can have multiple instances of it in the same stack</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="level" type="xs:string">
       <xs:annotation>
        <xs:documentation>Sets the logger level (see javadocs)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
     </xs:complexType>
    </xs:element>
    <xs:element name="pbcast.FLUSH">
     <xs:complexType>
      <xs:attribute name="timeout" type="xs:string">
       <xs:annotation>
        <xs:documentation>Max time to keep channel blocked in flush. Default is 8000 msec</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="start_flush_timeout" type="xs:string">
       <xs:annotation>
        <xs:documentation>Timeout (per atttempt) to quiet the cluster during the first flush phase. Default is 2000 msec</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="end_flush_timeout" type="xs:string">
       <xs:annotation>
        <xs:documentation>Timeout to wait for UNBLOCK after STOP_FLUSH is issued. Default is 2000 msec</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="retry_timeout" type="xs:string">
       <xs:annotation>
        <xs:documentation>Retry timeout after an unsuccessful attempt to quiet the cluster (first flush phase). Default is 3000 msec</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="enable_reconciliation" type="xs:string">
       <xs:annotation>
        <xs:documentation>Reconciliation phase toggle. Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="bypass" type="xs:string">
       <xs:annotation>
        <xs:documentation>When set, FLUSH is bypassed, same effect as if FLUSH wasn't in the config at all</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="stats" type="xs:string">
       <xs:annotation>
        <xs:documentation>Determines whether to collect statistics (and expose them via JMX). Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="ergonomics" type="xs:string">
       <xs:annotation>
        <xs:documentation>Enables ergonomics: dynamically find the best values for properties at runtime</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="name" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different name if needed so we can have multiple instances of it in the same stack (also change ID)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="id" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different ID if needed so we can have multiple instances of it in the same stack</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="level" type="xs:string">
       <xs:annotation>
        <xs:documentation>Sets the logger level (see javadocs)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
     </xs:complexType>
    </xs:element>
    <xs:element name="tom.TOA">
     <xs:complexType>
      <xs:attribute name="stats" type="xs:string">
       <xs:annotation>
        <xs:documentation>Determines whether to collect statistics (and expose them via JMX). Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="ergonomics" type="xs:string">
       <xs:annotation>
        <xs:documentation>Enables ergonomics: dynamically find the best values for properties at runtime</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="name" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different name if needed so we can have multiple instances of it in the same stack (also change ID)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="id" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different ID if needed so we can have multiple instances of it in the same stack</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="level" type="xs:string">
       <xs:annotation>
        <xs:documentation>Sets the logger level (see javadocs)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
     </xs:complexType>
    </xs:element>
    <xs:element name="relay.RELAY2">
     <xs:complexType>
      <xs:attribute name="site" type="xs:string">
       <xs:annotation>
        <xs:documentation>Name of the site (needs to be defined in the configuration)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="config" type="xs:string">
       <xs:annotation>
        <xs:documentation>Name of the relay configuration</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="can_become_site_master" type="xs:string">
       <xs:annotation>
        <xs:documentation>Whether or not this node can become the site master. If false, and we become the coordinator, we won't start the bridge(s)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="enable_address_tagging" type="xs:string">
       <xs:annotation>
        <xs:documentation>Whether or not we generate our own addresses in which we use can_become_site_master. If this property is false, can_become_site_master is ignored</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="relay_multicasts" type="xs:string">
       <xs:annotation>
        <xs:documentation>Whether or not to relay multicast (dest=null) messages</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="max_forward_attempts" type="xs:string">
       <xs:annotation>
        <xs:documentation>The number of tries to forward a message to a remote site</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="forward_sleep" type="xs:string">
       <xs:annotation>
        <xs:documentation>The time (in milliseconds) to sleep between forward attempts</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="fwd_queue_max_size" type="xs:string">
       <xs:annotation>
        <xs:documentation>Max number of messages in the foward queue. Messages are added to the forward queue when the status of a route went from UP to UNKNOWN and the queue is flushed when the status goes to UP (resending all queued messages) or DOWN (sending SITE-UNREACHABLE messages to the senders)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="site_down_timeout" type="xs:string">
       <xs:annotation>
        <xs:documentation>Number of millisconds to wait when the status for a site changed from UP to UNKNOWN before that site is declared DOWN. A site that's DOWN triggers immediate sending of a SITE-UNREACHABLE message back to the sender of a message to that site</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="async_relay_creation" type="xs:string">
       <xs:annotation>
        <xs:documentation>If true, the creation of the relay channel (and the connect()) are done in the background. Async relay creation is recommended, so the view callback won't be blocked</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="warn_when_ftc_missing" type="xs:string">
       <xs:annotation>
        <xs:documentation>If true, logs a warning if the FORWARD_TO_COORD protocol is not found. This property might get deprecated soon</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="stats" type="xs:string">
       <xs:annotation>
        <xs:documentation>Determines whether to collect statistics (and expose them via JMX). Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="ergonomics" type="xs:string">
       <xs:annotation>
        <xs:documentation>Enables ergonomics: dynamically find the best values for properties at runtime</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="name" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different name if needed so we can have multiple instances of it in the same stack (also change ID)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="id" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different ID if needed so we can have multiple instances of it in the same stack</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="level" type="xs:string">
       <xs:annotation>
        <xs:documentation>Sets the logger level (see javadocs)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
     </xs:complexType>
    </xs:element>
    <xs:element name="rules.SUPERVISOR">
     <xs:complexType>
      <xs:attribute name="config" type="xs:string">
       <xs:annotation>
        <xs:documentation>Location of an XML file listing the rules to be installed</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="stats" type="xs:string">
       <xs:annotation>
        <xs:documentation>Determines whether to collect statistics (and expose them via JMX). Default is true</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="ergonomics" type="xs:string">
       <xs:annotation>
        <xs:documentation>Enables ergonomics: dynamically find the best values for properties at runtime</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="name" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different name if needed so we can have multiple instances of it in the same stack (also change ID)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="id" type="xs:string">
       <xs:annotation>
        <xs:documentation>Give the protocol a different ID if needed so we can have multiple instances of it in the same stack</xs:documentation>
       </xs:annotation>
      </xs:attribute>
      <xs:attribute name="level" type="xs:string">
       <xs:annotation>
        <xs:documentation>Sets the logger level (see javadocs)</xs:documentation>
       </xs:annotation>
      </xs:attribute>
     </xs:complexType>
    </xs:element>
   </xs:choice>
  </xs:complexType>
 </xs:element>
</xs:schema>
