<FindBugsFilter>

  <Match>
    <!-- Having str restored to null is fine for our purposes -->
    <Class name="org.hornetq.api.core.SimpleString"/>
    <Field name="str"/>
    <Bug pattern="SE_TRANSIENT_FIELD_NOT_RESTORED"/>
  </Match>

  <Match>
    <!-- The whole point of SimpleString is to expose this data without any performance penalty -->
    <Class name="org.hornetq.api.core.SimpleString"/>
    <method name="getData"/>
    <Bug pattern="EI_EXPOSE_REP"/>
  </Match>

  <!-- Ok to return mutable Object -->
  <Match>
    <Or>
      <Class name="org.hornetq.core.protocol.core.impl.wireformat.ReplicationStartSyncMessage" />
      <Class name="org.hornetq.core.protocol.core.impl.wireformat.ReplicationSyncFileMessage" />
      <Class name="org.hornetq.core.protocol.core.impl.wireformat.ReplicationLargeMessageWriteMessage" />
    </Or>
    <Bug pattern="EI_EXPOSE_REP"/>
  </Match>
  <!-- Ok to return mutable Object, here restricted to method getRecordData -->
  <Match>
    <Or>
      <Class name="org.hornetq.core.protocol.core.impl.wireformat.ReplicationAddMessage" />
      <Class name="org.hornetq.core.protocol.core.impl.wireformat.ReplicationAddTXMessage" />
      <Class name="org.hornetq.core.protocol.core.impl.wireformat.ReplicationDeleteTXMessage" />
      <Class name="org.hornetq.core.protocol.core.impl.wireformat.ReplicationPrepareMessage" />
    </Or>
    <Method name="getRecordData" />
    <Bug pattern="EI_EXPOSE_REP"/>
  </Match>

  <!-- Comparison is correct within its context -->
  <Match>
    <Class name="org.hornetq.ra.HornetQRaUtils"/>
    <Or>
      <Method name="compare" params="java.lang.Integer,java.lang.Integer" returns="boolean"/>
      <Method name="compare" params="java.lang.Long,java.lang.Long" returns="boolean"/>
      <Method name="compare" params="java.lang.Double,java.lang.Double" returns="boolean"/>
    </Or>
    <Bug pattern="RC_REF_COMPARISON"/>
  </Match>

  <!-- Comparison is correct within its context -->
  <Match>
    <Class name="org.hornetq.ra.Util"/>
    <Method name="compare" params="java.lang.Boolean,java.lang.Boolean" returns="boolean"/>
    <Bug pattern="RC_REF_COMPARISON_BAD_PRACTICE_BOOLEAN"/>
  </Match>

  <!-- Comparison is correct within its context -->
  <Match>
    <Class name="org.hornetq.ra.Util"/>
    <Method name="compare" params="java.lang.String,java.lang.String" returns="boolean"/>
    <Bug pattern="ES_COMPARING_PARAMETER_STRING_WITH_EQ"/>
  </Match>

  <Match>
    <!-- As per Java Messaging Specification 3.5.4:

         "
         Attempting to read a null value as a Java primitive type must be treated
         as calling the primitiveâ€™s corresponding valueOf(String) conversion method
         with a null value.
         "

         so methods are passed null arguments to trigger the exact same exceptions.
    -->
    <Class name="org.hornetq.utils.TypedProperties"/>
    <Or>
      <Method name="getFloatProperty"/>
      <Method name="getDoubleProperty"/>
      <Method name="getByteProperty"/>
      <Method name="getIntProperty"/>
      <Method name="getShortProperty"/>
    </Or>
    <Bug pattern="NP_NULL_PARAM_DEREF_NONVIRTUAL"/>
  </Match>

  <Match>
    <!-- Code is meant to measure memory usage, so calling Garbage Collection is normal. -->
    <Class name="org.hornetq.utils.MemorySize"/>
    <bug pattern="DM_GC"/>
  </Match>

  <match>
    <!-- Ignore naming convention violations in generated code -->
    <class name="org.hornetq.core.filter.impl.FilterParser"/>
    <bug pattern="NM_METHOD_NAMING_CONVENTION"/>
  </match>

  <Match>
    <!-- field changes are always guarded by PagingStoreImpl.lock.writeLock().lock() -->
    <Class name="org.hornetq.core.paging.impl.PagingStoreImpl"/>
    <Field name="numberOfPages" />
    <Bug pattern="VO_VOLATILE_INCREMENT"/>
  </Match>

  <Match>
    <!-- File is generated by JavaCC -->
    <Class name="org.hornetq.core.filter.impl.ParseException"/>
    <bug pattern="SBSC_USE_STRINGBUFFER_CONCATENATION"/>
  </Match>

  <Match>
    <!-- Generated by JavaCC: ignore naming convention violation -->
    <Class name="~org\.hornetq\.core\.filter\.impl\.(FilterParser(|TokenManager|Constants)|TokenMgrError)"/>
    <bug pattern="NM_METHOD_NAMING_CONVENTION,SF_SWITCH_NO_DEFAULT,MS_PKGPROTECT,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,MS_OOI_PKGPROTECT"/>
  </Match>

  <Match>
    <!-- Files generated by JBoss Logging are ignored -->
    <Class name="~org\.hornetq\..*\.HornetQ.*(Logger_\$logger|Bundle_\$bundle)"/>
  </Match>

  <!-- Ignore checks on return values, example File.delete(), on samples/examples -->
  <Match>
    <Class name="~org\.hornetq\.common\.example.*Example"/>
    <bug pattern="RV_RETURN_VALUE_IGNORED_BAD_PRACTICE"/>
  </Match>

  <Match>
    <Class name="org.hornetq.utils.json.JSONObject$Null"/>
    <Bug pattern="EQ_UNUSUAL"/>
  </Match>

  <Match>
    <Class name="org.hornetq.core.server.impl.HornetQServerImpl$SharedNothingLiveActivation"/>
    <Method name="isNodeIdUsed"/>
    <Bug pattern="RV_RETURN_VALUE_IGNORED"/>
  </Match>

  <!-- Examples often verify a null value and use the (null) variable in a sys-out statement -->
  <Match>
    <Or>
      <Class name="org.hornetq.jms.example.TopicHierarchyExample"/>
      <Class name="org.hornetq.jms.example.TransactionalExample"/>
    </Or>
    <Method name="runExample"/>
    <Bug pattern="NP_LOAD_OF_KNOWN_NULL_VALUE"/>
  </Match>

</FindBugsFilter>
