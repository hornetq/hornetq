<html>
  <head>
    <title>HornetQ JMS Automatic (Transparent) Failover Example</title>
    <link rel="stylesheet" type="text/css" href="../../common/common.css" />
    <link rel="stylesheet" type="text/css" href="../../common/prettify.css" />
    <script type="text/javascript" src="../../common/prettify.js"></script>
  </head>
  <body onload="prettyPrint()">
     <h1>HornetQ JMS Automatic (Transparent) Failover (HA) Example</h1>
     <br>
     <p>This example demonstrates two servers coupled as a live-backup pair for high availability (HA), and a client
     connection transparently failing over from live to backup when the live server is crashed.</p>
     <p>HornetQ implements seamless, transparent failover of client connections between live and backup servers.
     This is implemented by the replication of state between live and backup nodes. When replication is configured and a
     live node crashes, the client connections can carry on as if <i>nothing happened</i> and carry on sending and
     consuming messages.</p>
     <p><b>With HornetQ there is no need to code any special client side failover logic in order to benefit from
     failover and HA. There is no need to refactor your messaging applications to work in an HA environment.</b></p>
     <p>HornetQ also supports manual failover which is covered in a separate example.</p> 
     <p>For more information on HornetQ failover and HA, and clustering in general, please see the clustering
     section of the user manual.</p>      
     <h2>Example step-by-step</h2>
     <p><i>To run the example, simply type <code>ant</code> from this directory</i></p>
     <p>In this example, the live server is server 1, and the backup server is server 0</p>
     <p>The connection will initially be created to server1, server 1 will crash, and the client will carry on
     seamlessly on server 0, the backup server.</p>
     <br>
     <ol>
        <li> Get an initial context for looking up JNDI from server 1.</li>
        <pre class="prettyprint">
           <code>initialContext = getContext(1);</code>
        </pre>

        <li>Look-up the JMS Queue object from JNDI on server 1.</li>
        <pre class="prettyprint">
           <code>Queue queue = (Queue)initialContext.lookup("/queue/exampleQueue");</code>
        </pre>

        <li>Look-up a JMS Connection Factory object from JNDI on server 1</li>
        <pre class="prettyprint">
           <code>ConnectionFactory connectionFactory = (ConnectionFactory)initialContext.lookup("/ConnectionFactory");</code>
        </pre>

        <li>We create a JMS Connection</li>
        <pre class="prettyprint">
          <code>connection = connectionFactory.createConnection();</code>
        </pre>
        
        <li>We create a JMS Session</li>
        <pre class="prettyprint">
           <code>Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);</code>
        </pre>
        
        <li>We start the connection to ensure delivery occurs on them</li>
        <pre class="prettyprint">
           <code>
   connection.start();
           </code>
        </pre>

        <li>We create a JMS MessageConsumer</li>
        <pre class="prettyprint">
           <code>
   MessageConsumer consumer = session.createConsumer(queue);
           </code>
        </pre>

        <li>We create a JMS MessageProducer</li>
        <pre class="prettyprint">
           <code>
   MessageProducer producer = session.createProducer(queue);</code>
        </pre>

        <li>We send some messages to server 1, the live server. As we do operations on the live server they are
        transparently replicated to server 0 the backup server, behind the scenes.</li>
        <pre class="prettyprint">
           <code>
	      final int numMessages = 10;

         for (int i = 0; i < numMessages; i++)
         {
            TextMessage message = session.createTextMessage("This is text message " + i);

            producer.send(message);

            System.out.println("Sent message: " + message.getText());
         }
           </code>
        </pre>
        
        <li>We now cause server 1, the live server, to crash, and wait a little while to make sure
            it has really crashed. When server 1 crashes, the client automatically detects the failure and automatically
            fails over from server 1 to server 0. (In your real program you wouldn't need to sleep).
        </li>
       
        <pre class="prettyprint">
           <code>
	      killServer(1); // This causes the live server to crash
         
         Thread.sleep(2000); // Just wait a little while to make sure the live server has really crashed.
           </code>
        </pre> 
        
        <li>We consume the messages sent before the crash of the live server. We are now transparently
            reconnected to server 0 - the backup server. Note that all this reconnection has been done
            without the client being aware it has been reconnected!</li>
        <pre class="prettyprint">
           <code>
         for (int i = 0; i < numMessages; i++)
         {
            TextMessage message0 = (TextMessage)consumer.receive(5000);

            System.out.println("Got message: " + message0.getText());
         }
           </code>
        </pre>
        
        <li>We now send some more messages.</li>
        <pre class="prettyprint">
           <code>
         for (int i = numMessages; i < numMessages * 2; i++)
         {
            TextMessage message = session.createTextMessage("This is text message " + i);

            producer.send(message);

            System.out.println("Sent message: " + message.getText());
         }
           </code>
        </pre>
        
        <li>And consume them.</li>
        <pre class="prettyprint">
           <code>
         for (int i = 0; i < numMessages; i++)
         {
            TextMessage message0 = (TextMessage)consumer.receive(5000);

            System.out.println("Got message: " + message0.getText());
         }
           </code>
        </pre>

        <li>And finally (no pun intended), <b>always</b> remember to close your resources after use, in a <code>finally</code> block. Closing a JMS connection will automatically close all of its sessions, consumers, producer and browser objects</li>

        <pre class="prettyprint">
           <code>
	finally
	{
	   if (connection != null)
      {
         connection.close();
      }

      if (initialContext != null)
      {
         initialContext.close();
      }
	}
           </code>
        </pre>

     </ol>
  </body>
</html>