<html>
  <head>
    <title>HornetQ JMS Client Side Load-Balancing Example</title>
    <link rel="stylesheet" type="text/css" href="../../common/common.css" />
    <link rel="stylesheet" type="text/css" href="../../common/prettify.css" />
    <script type="text/javascript" src="../../common/prettify.js"></script>
  </head>
  <body onload="prettyPrint()">
     <h1>HornetQ JMS Client Side Load-Balancing Example</h1>
     <br>
     <p>This example demonstrates how subsequent connections created from a JMS Connection Factory can be created
     to different nodes of the cluster. In other words it demonstrates how HornetQ does <b>client side load balancing</b> of
     connections across the cluster.</p>
     <p>The particular load-balancing policy can be chosen to be random, round-robin or user-defined. Please see the user
     guide for more details of how to configure the specific load-balancing policy. In this example we will use
     the default round-robin load balancing policy.</p>
     <p>The list of servers over which HornetQ will round-robin the connections can either be specified explicitly
     in the connection factory when creating it, or deploying it on the server, or the factory can be configured
     to use UDP discovery to discover the list of servers over which to round-robin. This example will use UDP
     discovery to obtain the list.</p>
     <p>This example starts three servers which all broadcast their location using UDP discovery. The UDP broadcast configuration
     can be seen in the <code>hornetq-configuration.xml</code> file.</p>
     <p>A JMS ConnectionFactory is deployed on each server specifying the discovery group that will be used by that
     connection factory.</p>      
     <p>For more information on HornetQ load balancing, and clustering in general, please see the clustering
     section of the user manual.</p>      
     <h2>Example step-by-step</h2>
     <p><i>To run the example, simply type <code>ant</code> from this directory</i></p>
     <br>
     <ol>
        <li> Get an initial context for looking up JNDI from server 0.</li>
        <pre class="prettyprint">>
           <code>
   initialContext = getContext(0);
   </code>
        </pre>

        <li>Look-up the JMS Queue object from JNDI</li>
        <pre class="prettyprint">
           <code>Queue queue = (Queue)initialContext.lookup("/queue/exampleQueue");</code>
        </pre>

        <li>Look-up a JMS Connection Factory object from JNDI on server 0</li>
        <pre class="prettyprint">
           <code>ConnectionFactory connectionFactory = (ConnectionFactory)initialContext.lookup("/ConnectionFactory");</code>
        </pre>

        <li>We create three connections, since we are using round-robin load-balancing this should
        result in each connection being connected to a different node of the cluster</li>
        <pre class="prettyprint">
           <code>
        connectionA = connectionFactory.createConnection();
         
        connectionB = connectionFactory.createConnection();
         
        connectionC = connectionFactory.createConnection();
           </code>
        </pre>

        <li>We create a JMS Session on each of those connections</li>
        <pre class="prettyprint">
           <code>
        Session sessionA = connectionA.createSession(false, Session.AUTO_ACKNOWLEDGE);
         
        Session sessionB = connectionB.createSession(false, Session.AUTO_ACKNOWLEDGE);
         
        Session sessionC = connectionC.createSession(false, Session.AUTO_ACKNOWLEDGE);
           </code>
        </pre>

        <li>We start the connections to ensure delivery occurs on them</li>
        <pre class="prettyprint">
          <code>
        connectionA.start();

        connectionB.start();
         
        connectionC.start();
          </code>
        </pre>
        
        <li>We create JMS MessageConsumer objects on the sessions</li>
        <pre class="prettyprint">
          <code>
         MessageConsumer consumerA = sessionA.createConsumer(queue);
         
         MessageConsumer consumerB = sessionB.createConsumer(queue);
         
         MessageConsumer consumerC = sessionC.createConsumer(queue);
          </code>
        </pre>

        <li>We create JMS MessageProducer objects on the sessions</li>
        <pre class="prettyprint">
           <code>
        MessageProducer producerA = sessionA.createProducer(queue);
         
        MessageProducer producerB = sessionB.createProducer(queue);
         
        MessageProducer producerC = sessionC.createProducer(queue);
           </code>
        </pre>
        
        <li>We send some messages on each producer</li>
        <pre class="prettyprint">
           <code>
         final int numMessages = 10;

         for (int i = 0; i < numMessages; i++)
         {
            TextMessage messageA = sessionA.createTextMessage("A:This is text message " + i);

            producerA.send(messageA);

            System.out.println("Sent message: " + messageA.getText());
            
            TextMessage messageB = sessionB.createTextMessage("B:This is text message " + i);

            producerB.send(messageB);

            System.out.println("Sent message: " + messageB.getText());
            
            TextMessage messageC = sessionC.createTextMessage("C:This is text message " + i);

            producerC.send(messageC);

            System.out.println("Sent message: " + messageC.getText());            
         }
            </code>
        </pre>

        <li>We now consume the messages from each node. The connections must be on different nodes
         since if they shared nodes then the consumers would receive the messages sent from different connections.</li>
        <pre class="prettyprint">
           <code>
         for (int i = 0; i < numMessages; i ++)
         {
            TextMessage messageA = (TextMessage)consumerA.receive(5000);

            System.out.println("Got message: " + messageA.getText() + " from node A");
            
            TextMessage messageB = (TextMessage)consumerB.receive(5000);

            System.out.println("Got message: " + messageB.getText() + " from node B");
            
            TextMessage messageC = (TextMessage)consumerC.receive(5000);

            System.out.println("Got message: " + messageC.getText() + " from node C");
         }
           </code>
        </pre>

        <li>And finally (no pun intended), <b>always</b> remember to close your JMS resources after use, in a <code>finally</code> block. Closing a JMS connection will automatically close all of its sessions, consumers, producer and browser objects</li>

        <pre class="prettyprint">
           <code>
	finally
	{
	   if (connection0 != null)
	   {
	      connection0.close();
	   }
	      
	   if (connection1 != null)
	   {
	      connection1.close();
	   }
	}
           </code>
        </pre>

     </ol>
  </body>
</html>