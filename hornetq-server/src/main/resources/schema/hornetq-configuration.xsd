<?xml version="1.0" encoding="UTF-8"?>
<xsd:schema xmlns="urn:hornetq" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:hq="urn:org.hornetq"
  attributeFormDefault="unqualified" elementFormDefault="qualified" targetNamespace="urn:hornetq"
  version="1.0">

  <xsd:element name="configuration" type="configurationType" hq:schema="hornetq-configuration"/>

    <xsd:complexType name="configurationType">
      <xsd:all>
        <xsd:element name="name" type="xsd:string" maxOccurs="1" minOccurs="0">
          <xsd:annotation>
            <xsd:documentation>Node name. If set, it will be used in topology
            notifications.</xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element name="resolveProtocols" type="xsd:boolean" default="true" maxOccurs="1"
                       minOccurs="0">
           <xsd:annotation hq:linkend="resolveProtocols" hq:field_name="DEFAULT_RESOLVE_PROTOCOLS">
               <xsd:documentation>If true then the HornetQ Server will make use of any Protocol Managers that are in available
                   on the classpath. If false then only the core protocol will be available, unless in Embedded mode where
                   users can inject their own Protocol Managers.
               </xsd:documentation>
           </xsd:annotation>
        </xsd:element>

        <xsd:element name="clustered" type="xsd:boolean" default="false" maxOccurs="1"
                     minOccurs="0">
          <xsd:annotation hq:linkend="clusters">
            <xsd:documentation>DEPRECATED. This option is deprecated and its value will be
            ignored (HQ221038). A HornetQ server will be "clustered" when its configuration
            contain a cluster-configuration.
            </xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element name="check-for-live-server" type="xsd:boolean" default="false" maxOccurs="1"
                     minOccurs="0">
          <xsd:annotation hq:linkend="hq.check-for-live-server" hq:field_name="DEFAULT_CHECK_FOR_LIVE_SERVER">
            <xsd:documentation>
              Whether to check the cluster for a (live) server using our own server ID when starting
              up. This option is only necessary for performing 'fail-back' on replicating
              servers. Strictly speaking this setting only applies to live servers and not to
              backups.
            </xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element name="file-deployment-enabled" type="xsd:boolean" default="false"
                     maxOccurs="1" minOccurs="0">
          <xsd:annotation hq:linkend="using-server.configuration"
                          hq:field_name="DEFAULT_FILE_DEPLOYMENT_ENABLED">
            <xsd:documentation>true means that the server will load configuration from the
            configuration files
            </xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element name="persistence-enabled" type="xsd:boolean" default="true"
                     maxOccurs="1" minOccurs="0">
          <xsd:annotation hq:linkend="persistence.enabled" hq:field_name="DEFAULT_PERSISTENCE_ENABLED">
            <xsd:documentation>true means that the server will use the file based journal for
              persistence.
            </xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element name="scheduled-thread-pool-max-size" type="xsd:int" default="5"
                     maxOccurs="1" minOccurs="0">
          <xsd:annotation hq:linkend="server.scheduled.thread.pool"
                          hq:field_name="DEFAULT_SCHEDULED_THREAD_POOL_MAX_SIZE">
            <xsd:documentation>
              Maximum number of threads to use for the scheduled thread pool
            </xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element name="thread-pool-max-size" type="xsd:int" default="30" maxOccurs="1"
                     minOccurs="0">
          <xsd:annotation hq:linkend="server.scheduled.thread.pool"
                          hq:field_name="DEFAULT_THREAD_POOL_MAX_SIZE">
            <xsd:documentation>
              Maximum number of threads to use for the thread pool. -1 means 'no limits'.
            </xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element name="security-enabled" type="xsd:boolean" default="true"
          maxOccurs="1" minOccurs="0">
          <xsd:annotation hq:linkend="security" hq:field_name="DEFAULT_SECURITY_ENABLED" >
            <xsd:documentation>true means that security is enabled</xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element name="security-invalidation-interval" type="xsd:long" default="10000" maxOccurs="1" minOccurs="0">
          <xsd:annotation hq:linkend="security" hq:field_name="DEFAULT_SECURITY_INVALIDATION_INTERVAL">
            <xsd:documentation>how long (in ms) to wait before invalidating the security cache
            </xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element name="wild-card-routing-enabled" type="xsd:boolean" default="true"
                     maxOccurs="1" minOccurs="0">
          <xsd:annotation hq:linkend="wildcard-routing" hq:field_name="DEFAULT_WILDCARD_ROUTING_ENABLED">
            <xsd:documentation>true means that the server supports wild card routing
            </xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element name="management-address" type="xsd:string" default="jms.queue.hornetq.management"
                     maxOccurs="1" minOccurs="0">
          <xsd:annotation hq:linkend="management.core.configuration"
                          hq:field_name="DEFAULT_MANAGEMENT_ADDRESS"
                          hq:type="SimpleString">
            <xsd:documentation>
              the name of the management address to send management messages to. It is prefixed with
              "jms.queue" so that JMS clients can send messages to it.
            </xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element name="management-notification-address" type="xsd:string" default="hornetq.notifications"
                     maxOccurs="1" minOccurs="0">
          <xsd:annotation hq:linkend="management.notifications.core.configuration"
                          hq:field_name="DEFAULT_MANAGEMENT_NOTIFICATION_ADDRESS"
                          hq:type="SimpleString">
            <xsd:documentation>the name of the address that consumers bind to receive management
            notifications
            </xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element name="cluster-user" type="xsd:string" default="HORNETQ.CLUSTER.ADMIN.USER"
                     maxOccurs="1" minOccurs="0">
          <xsd:annotation hq:linkend="clusters" hq:field_name="DEFAULT_CLUSTER_USER">
            <xsd:documentation>Cluster username. It applies to all cluster configurations.
            </xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element maxOccurs="1" minOccurs="0" name="cluster-password" type="xsd:string"
                     default="CHANGE ME!!">
          <xsd:annotation hq:linkend="clusters" hq:field_name="DEFAULT_CLUSTER_PASSWORD">
            <xsd:documentation>Cluster password. It applies to all cluster configurations.
            </xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element name="replication-clustername" type="xsd:string" maxOccurs="1" minOccurs="0">
          <xsd:annotation>
            <xsd:documentation>
              Name of the cluster configuration to use for replication. This setting is only
              necessary in case you configure multiple cluster connections. It is used by a
              replicating backups and by live servers that may attempt fail-back.
            </xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element name="max-saved-replicated-journals-size" type="xsd:int" default="2" maxOccurs="1" minOccurs="0">
          <xsd:annotation hq:field_name="DEFAULT_MAX_SAVED_REPLICATED_JOURNALS_SIZE">
            <xsd:documentation>
              This specifies how many times a replicated backup server can restart after moving
              its files on start. Once there are this number of backup journal files the server
              will stop permanently after if fails back.
            </xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element name="password-codec" type="xsd:string"
                     default="org.hornetq.utils.DefaultSensitiveStringCodec" maxOccurs="1" minOccurs="0">
          <xsd:annotation hq:linkend="configuration.masked-password">
            <xsd:documentation>
              Class name and its parameters for the Decoder used to decode the masked password.
              Ignored if mask-password is false. The format of this property is a full qualified
              class name optionally followed by key/value pairs.
            </xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element name="mask-password" type="xsd:boolean" default="false" maxOccurs="1"
                     minOccurs="0">
          <xsd:annotation hq:linkend="configuration.masked-password" hq:field_name="DEFAULT_MASK_PASSWORD">
            <xsd:documentation>
              This option controls whether passwords in server configuration need be masked.  If set
              to "true" the passwords are masked.
            </xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element name="log-delegate-factory-class-name" type="xsd:string" maxOccurs="1"
                     minOccurs="0">
          <xsd:annotation hq:linkend="XXX">
            <xsd:documentation>XXX</xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element name="jmx-management-enabled" type="xsd:boolean" default="true" maxOccurs="1" minOccurs="0">
          <xsd:annotation hq:linkend="management.jmx.configuration"
                           hq:field_name="DEFAULT_JMX_MANAGEMENT_ENABLED">
            <xsd:documentation>true means that the management API is available via JMX
            </xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element name="jmx-domain" type="xsd:string" default="org.hornetq" maxOccurs="1" minOccurs="0">
          <xsd:annotation hq:linkend="management.jmx.configuration" hq:field_name="DEFAULT_JMX_DOMAIN">
            <xsd:documentation>the JMX domain used to registered HornetQ MBeans in the MBeanServer
            </xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element name="message-counter-enabled" type="xsd:boolean" default="false" maxOccurs="1" minOccurs="0">
          <xsd:annotation hq:linkend="configuring.message.counters" hq:field_name="DEFAULT_MESSAGE_COUNTER_ENABLED">
            <xsd:documentation>true means that message counters are enabled</xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element name="message-counter-sample-period" type="xsd:long" default="10000" maxOccurs="1" minOccurs="0">
          <xsd:annotation hq:linkend="configuring.message.counters" hq:field_name="DEFAULT_MESSAGE_COUNTER_SAMPLE_PERIOD">
            <xsd:documentation>the sample period (in ms) to use for message counters
            </xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element name="message-counter-max-day-history" type="xsd:int" default="10" maxOccurs="1" minOccurs="0">
          <xsd:annotation hq:linkend="configuring.message.counters" hq:default="(days)" hq:field_name="DEFAULT_MESSAGE_COUNTER_MAX_DAY_HISTORY">
            <xsd:documentation>how many days to keep message counter history
            </xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element name="connection-ttl-override" type="xsd:long" default="-1"
                     maxOccurs="1" minOccurs="0">
          <xsd:annotation hq:linkend="connection-ttl.override"
                          hq:field_name="DEFAULT_CONNECTION_TTL_OVERRIDE">
            <xsd:documentation>
              if set, this will override how long (in ms) to keep a connection alive without
              receiving a ping. -1 disables this setting.
            </xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element name="async-connection-execution-enabled" type="xsd:boolean"
                     default="true" maxOccurs="1" minOccurs="0">
          <xsd:annotation hq:linkend="connection-ttl.async-connection-execution"
                          hq:field_name="DEFAULT_ASYNC_CONNECTION_EXECUTION_ENABLED">
            <xsd:documentation>Should incoming packets on the server be handed off to a thread from
            the thread pool for processing or should they be handled on the remoting thread?
            </xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element name="transaction-timeout" type="xsd:long" default="300000" maxOccurs="1" minOccurs="0">
          <xsd:annotation hq:linkend="transaction-config" hq:field_name="DEFAULT_TRANSACTION_TIMEOUT">
            <xsd:documentation>
              how long (in ms) before a transaction can be removed from the resource manager after
              create time
            </xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element name="transaction-timeout-scan-period" type="xsd:long" default="1000" maxOccurs="1" minOccurs="0">
          <xsd:annotation hq:linkend="transaction-config" hq:field_name="DEFAULT_TRANSACTION_TIMEOUT_SCAN_PERIOD">
            <xsd:documentation>how often (in ms) to scan for timeout transactions
            </xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element name="message-expiry-scan-period" type="xsd:long" default="30000" maxOccurs="1" minOccurs="0">
          <xsd:annotation hq:linkend="configuring.expiry.reaper"
                          hq:field_name="DEFAULT_MESSAGE_EXPIRY_SCAN_PERIOD">
            <xsd:documentation>how often (in ms) to scan for expired messages
            </xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element name="message-expiry-thread-priority" type="xsd:int" default="3"
                     maxOccurs="1" minOccurs="0">
          <xsd:annotation hq:linkend="configuring.expiry.reaper" hq:field_name="DEFAULT_MESSAGE_EXPIRY_THREAD_PRIORITY">
            <xsd:documentation>the priority of the thread expiring messages
            </xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element name="id-cache-size" type="xsd:int" default="20000" maxOccurs="1" minOccurs="0">
          <xsd:annotation hq:linkend="duplicate.id.cache" hq:field_name="DEFAULT_ID_CACHE_SIZE">
            <xsd:documentation>the size of the cache for pre-creating message ID's
            </xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element name="persist-id-cache" type="xsd:boolean" default="true" maxOccurs="1" minOccurs="0">
          <xsd:annotation hq:linkend="duplicate.id.cache" hq:field_name="DEFAULT_PERSIST_ID_CACHE">
            <xsd:documentation>true means that ID's are persisted to the journal
            </xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element name="remoting-interceptors" type="class-name-sequenceType" maxOccurs="1" minOccurs="0">
          <xsd:annotation hq:linkend="intercepting-operations">
            <xsd:documentation>
              DEPRECATED. This option is deprecated, but it will still be honored. Any interceptor
              specified here will be considered an "incoming" interceptor. See
              &lt;remoting-incoming-interceptors&gt; and &lt;remoting-outgoing-interceptors&gt;.
            </xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element name="remoting-incoming-interceptors" type="class-name-sequenceType" maxOccurs="1" minOccurs="0">
          <xsd:annotation hq:linkend="intercepting-operations">
            <xsd:documentation>a list of &lt;class-name/&gt; elements with the names of classes to
            use for interceptor incoming remoting packets
            </xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element name="remoting-outgoing-interceptors" type="class-name-sequenceType" maxOccurs="1" minOccurs="0">
          <xsd:annotation hq:linkend="intercepting-operations">
            <xsd:documentation>a list of &lt;class-name/&gt; elements with the names of classes to
            use for interceptor outcoming remoting packets
            </xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element name="backup" type="xsd:boolean" default="false" maxOccurs="1" minOccurs="0">
          <xsd:annotation hq:linkend="ha" hq:field_name="DEFAULT_BACKUP">
            <xsd:documentation>whether this server is a backup server
            </xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element name="allow-failback" type="xsd:boolean" default="true" maxOccurs="1" minOccurs="0">
          <xsd:annotation hq:linkend="ha.allow-fail-back" hq:field_name="DEFAULT_ALLOW_AUTO_FAILBACK">
            <xsd:documentation>
              Whether a server will automatically stop when a another places a request to take over
              its place.  The use case is when a regular server stops and its backup takes over its
              duties, later the main server restarts and requests the server (the former backup) to
              stop operating.
            </xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element name="backup-group-name" type="xsd:string" maxOccurs="1" minOccurs="0">
          <xsd:annotation>
            <xsd:documentation>
              used for replication, if set, (remote) backup servers will only pair with live servers
              with matching backup-group-name
            </xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element name="failback-delay" type="xsd:long" default="5000" maxOccurs="1" minOccurs="0">
          <xsd:annotation hq:linkend="ha.allow-fail-back" hq:default="(in milliseconds)"
                          hq:field_name="DEFAULT_FAILBACK_DELAY">
            <xsd:documentation>delay to wait before fail-back occurs on (live's) restart</xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element name="failover-on-shutdown" type="xsd:boolean" default="false" maxOccurs="1" minOccurs="0">
          <xsd:annotation hq:linkend="ha.allow-fail-back" hq:field_name="DEFAULT_FAILOVER_ON_SERVER_SHUTDOWN">
            <xsd:documentation>
              Will this backup server come live on a normal server shutdown
            </xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element name="shared-store" type="xsd:boolean" default="true"  maxOccurs="1" minOccurs="0">
          <xsd:annotation hq:linkend="ha.mode.shared" hq:field_name="DEFAULT_SHARED_STORE">
            <xsd:documentation>
              'shared-store' applies to live and backup pairs, and it indicates if the live/backup
              pair share storage or if the data is replicated among them.
            </xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element name="persist-delivery-count-before-delivery" type="xsd:boolean" default="false"  maxOccurs="1" minOccurs="0">
          <xsd:annotation hq:linkend="configuring.delivery.count.persistence"
                          hq:field_name="DEFAULT_PERSIST_DELIVERY_COUNT_BEFORE_DELIVERY">
            <xsd:documentation>True means that the delivery count is persisted before delivery.
            False means that this only happens after a message has been cancelled.
            </xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element name="connectors" maxOccurs="1" minOccurs="0">
          <xsd:annotation hq:linkend="configuring-transports.connectors">
            <xsd:documentation>a list of remoting connectors configurations to create
            </xsd:documentation>
          </xsd:annotation>
          <xsd:complexType>
            <xsd:sequence>
              <xsd:element name="connector" maxOccurs="unbounded" minOccurs="0">
                <xsd:complexType>
                  <xsd:sequence>
                    <xsd:element maxOccurs="1" minOccurs="1" name="factory-class" type="xsd:string">
                      <xsd:annotation>
                        <xsd:documentation>Name of the ConnectorFactory implementation</xsd:documentation>
                      </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="param" type="paramType" maxOccurs="unbounded" minOccurs="0">
                      <xsd:annotation>
                        <xsd:documentation>A key-value pair used to configure the connector. A connector
                        can have many param's</xsd:documentation>
                      </xsd:annotation>
                    </xsd:element>
                  </xsd:sequence>
                  <xsd:attribute name="name" type="xsd:ID" use="required">
                  <xsd:annotation>
                    <xsd:documentation>Name of the connector</xsd:documentation>
                  </xsd:annotation>
                  </xsd:attribute>
                </xsd:complexType>
              </xsd:element>
            </xsd:sequence>
          </xsd:complexType>
        </xsd:element>

        <xsd:element maxOccurs="1" minOccurs="0" name="acceptors">
          <xsd:annotation hq:linkend="configuring-transports.acceptors">
            <xsd:documentation>a list of remoting acceptors to create
            </xsd:documentation>
          </xsd:annotation>
          <xsd:complexType>
            <xsd:sequence>
              <xsd:element name="acceptor" maxOccurs="unbounded" minOccurs="1">
                <xsd:complexType>
                  <xsd:sequence>
                    <xsd:element name="factory-class" type="xsd:string" maxOccurs="1" minOccurs="1">
                      <xsd:annotation>
                        <xsd:documentation>Name of the AcceptorFactory implementation</xsd:documentation>
                      </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="param" type="paramType" maxOccurs="unbounded" minOccurs="0">
                      <xsd:annotation>
                        <xsd:documentation>
                          A key-value pair used to configure the acceptor. An acceptor can have many
                        param</xsd:documentation>
                      </xsd:annotation>
                    </xsd:element>
                  </xsd:sequence>
                  <xsd:attribute name="name" type="xsd:string" use="optional">
                    <xsd:annotation>
                      <xsd:documentation>Name of the acceptor</xsd:documentation>
                    </xsd:annotation>
                  </xsd:attribute>
                </xsd:complexType>
              </xsd:element>
            </xsd:sequence>
          </xsd:complexType>
        </xsd:element>

        <xsd:element maxOccurs="1" minOccurs="0" name="broadcast-groups">
          <xsd:annotation hq:linkend="clusters">
            <xsd:documentation>a list of broadcast groups to create
            </xsd:documentation>
          </xsd:annotation>
          <xsd:complexType>
            <xsd:sequence>
              <xsd:element ref="broadcast-group" maxOccurs="unbounded" minOccurs="0"/>
            </xsd:sequence>
          </xsd:complexType>
        </xsd:element>

        <xsd:element maxOccurs="1" minOccurs="0" name="discovery-groups">
          <xsd:annotation hq:linkend="clusters">
            <xsd:documentation>a list of discovery groups to create
            </xsd:documentation>
          </xsd:annotation>
          <xsd:complexType>
            <xsd:sequence>
              <xsd:element maxOccurs="unbounded" minOccurs="0" ref="discovery-group">
                <xsd:annotation>
                  <xsd:documentation>a discovery group specification element</xsd:documentation>
                </xsd:annotation>
              </xsd:element>
            </xsd:sequence>
          </xsd:complexType>
        </xsd:element>

        <xsd:element name="diverts" maxOccurs="1" minOccurs="0">
          <xsd:annotation hq:linkend="diverts">
            <xsd:documentation>a list of diverts to use
            </xsd:documentation>
          </xsd:annotation>
          <xsd:complexType>
            <xsd:sequence>
              <xsd:element name="divert" type="divertType" maxOccurs="unbounded" minOccurs="0"/>
            </xsd:sequence>
          </xsd:complexType>
        </xsd:element>


        <!-- QUEUES -->
        <xsd:element name="queues" maxOccurs="1" minOccurs="0">
          <xsd:annotation hq:linkend="predefined.queues">
            <xsd:documentation>a list of pre configured queues to create
            </xsd:documentation>
          </xsd:annotation>
          <xsd:complexType>
            <xsd:sequence>
              <xsd:element name="queue" maxOccurs="unbounded" minOccurs="0">
                <xsd:complexType>
                  <xsd:all>
                    <xsd:element name="address" type="xsd:string" maxOccurs="1" minOccurs="1">
                      <xsd:annotation>
                        <xsd:documentation>address for the queue</xsd:documentation>
                      </xsd:annotation>
                    </xsd:element>
                    <xsd:element ref="filter" maxOccurs="1" minOccurs="0"/>
                    <xsd:element name="durable" type="xsd:boolean" default="true" maxOccurs="1" minOccurs="0">
                      <xsd:annotation>
                        <xsd:documentation>whether the queue is durable (persistent)</xsd:documentation>
                      </xsd:annotation>
                    </xsd:element>
                  </xsd:all>
                  <xsd:attribute name="name" type="xsd:ID" use="required">
                      <xsd:annotation>
                        <xsd:documentation>unique name of this queue</xsd:documentation>
                      </xsd:annotation>
                  </xsd:attribute>
               </xsd:complexType>
              </xsd:element>
            </xsd:sequence>
          </xsd:complexType>
        </xsd:element>

        <xsd:element name="bridges" maxOccurs="1" minOccurs="0">
          <xsd:annotation hq:linkend="core-bridges">
            <xsd:documentation>a list of bridges to create
            </xsd:documentation>
          </xsd:annotation>
          <xsd:complexType>
            <xsd:sequence>
              <xsd:element name="bridge" type="bridgeType" maxOccurs="unbounded" minOccurs="0"/>
            </xsd:sequence>
          </xsd:complexType>
        </xsd:element>

        <xsd:element name="cluster-connections" maxOccurs="1" minOccurs="0">
          <xsd:annotation hq:linkend="clusters">
            <xsd:documentation>a list of cluster connections
            </xsd:documentation>
          </xsd:annotation>
          <xsd:complexType>
            <xsd:sequence>
              <xsd:element name="cluster-connection" type="cluster-connectionType" maxOccurs="unbounded" minOccurs="0"/>
            </xsd:sequence>
          </xsd:complexType>
        </xsd:element>

        <xsd:element name="grouping-handler" type="groupingHandlerType" maxOccurs="1" minOccurs="0">
          <xsd:annotation hq:linkend="message-grouping">
            <xsd:documentation>Message Group configuration</xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element name="paging-directory" type="xsd:string" default="data/paging"  maxOccurs="1" minOccurs="0">
          <xsd:annotation hq:linkend="paging.main.config" hq:field_name="DEFAULT_PAGING_DIR">
            <xsd:documentation>the directory to store paged messages in</xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element name="bindings-directory" type="xsd:string" default="data/bindings" maxOccurs="1" minOccurs="0">
          <xsd:annotation hq:linkend="configuring.bindings.journal"
                          hq:field_name="DEFAULT_BINDINGS_DIRECTORY">
            <xsd:documentation>the directory to store the persisted bindings to</xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element name="create-bindings-dir" type="xsd:boolean" default="true" maxOccurs="1" minOccurs="0">
          <xsd:annotation hq:linkend="configuring.bindings.journal"
                          hq:field_name="DEFAULT_CREATE_BINDINGS_DIR">
            <xsd:documentation>true means that the server will create the bindings directory on
            start up
            </xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element name="page-max-concurrent-io" type="xsd:int" default="5" maxOccurs="1" minOccurs="0">
          <xsd:annotation hq:linkend="paging.mode" hq:field_name="DEFAULT_MAX_CONCURRENT_PAGE_IO">
            <xsd:documentation>The max number of concurrent reads allowed on paging
            </xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element name="journal-directory" type="xsd:string" default="data/journal"
                     maxOccurs="1" minOccurs="0">
          <xsd:annotation hq:linkend="configuring.message.journal.journal-directory"
                          hq:field_name="DEFAULT_JOURNAL_DIR">
            <xsd:documentation>the directory to store the journal files in</xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element name="create-journal-dir" type="xsd:boolean" default="true" maxOccurs="1" minOccurs="0">
          <xsd:annotation hq:linkend="configuring.message.journal.create-journal-dir"
                          hq:field_name="DEFAULT_CREATE_JOURNAL_DIR">
            <xsd:documentation>true means that the journal directory will be created
            </xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element name="journal-type" default="ASYNCIO" maxOccurs="1" minOccurs="0">
          <xsd:annotation hq:linkend="configuring.message.journal.journal-type">
            <xsd:documentation>the type of journal to use
            </xsd:documentation>
          </xsd:annotation>
          <xsd:simpleType>
            <xsd:restriction base="xsd:string">
              <xsd:enumeration value="ASYNCIO" />
              <xsd:enumeration value="NIO" />
            </xsd:restriction>
          </xsd:simpleType>
        </xsd:element>

        <xsd:element name="journal-buffer-timeout" type="xsd:long" maxOccurs="1" minOccurs="0">
          <xsd:annotation hq:linkend="configuring.message.journal.journal-buffer-timeout">
            <xsd:documentation>The timeout (in nanoseconds) used to flush internal buffers on the
            journal. The exact default value depend on whether the
            journal is ASYNCIO or NIO.
            </xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element name="journal-buffer-size" type="xsd:long" default="501760" maxOccurs="1" minOccurs="0">
          <xsd:annotation hq:linkend="configuring.message.journal.journal-buffer-size"
                          hq:default="(490 KiB)">
            <xsd:documentation>The size of the internal buffer on the journal in KiB.
            </xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element name="journal-sync-transactional" type="xsd:boolean" default="true" maxOccurs="1" minOccurs="0">
          <xsd:annotation hq:linkend="configuring.message.journal.journal-sync-transactional"
                          hq:field_name="DEFAULT_JOURNAL_SYNC_TRANSACTIONAL">
            <xsd:documentation>if true wait for transaction data to be synchronized to the journal
            before returning response to client
            </xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element name="journal-sync-non-transactional" type="xsd:boolean" default="true" maxOccurs="1" minOccurs="0">
          <xsd:annotation hq:linkend="configuring.message.journal.journal-sync-non-transactional"
                          hq:field_name="DEFAULT_JOURNAL_SYNC_NON_TRANSACTIONAL">
            <xsd:documentation>if true wait for non transaction data to be synced to the journal
            before returning response to client.
            </xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element name="log-journal-write-rate" type="xsd:boolean" default="false"
                     maxOccurs="1" minOccurs="0">
          <xsd:annotation hq:field_name="DEFAULT_JOURNAL_LOG_WRITE_RATE">
            <xsd:documentation>Whether to log messages about the journal write rate</xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element name="journal-file-size" default="10485760" type="xsd:int" maxOccurs="1" minOccurs="0">
          <xsd:annotation hq:linkend="configuring.message.journal.journal-file-size"
                          hq:default="(10 * 1024 * 1024 - 10 MiB)"
                          hq:field_name="DEFAULT_JOURNAL_FILE_SIZE">
            <xsd:documentation>the size (in bytes) of each journal file
            </xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element name="journal-min-files" type="xsd:int" default="2"  maxOccurs="1" minOccurs="0">
          <xsd:annotation hq:linkend="configuring.message.journal.journal-min-files"
                          hq:field_name="DEFAULT_JOURNAL_MIN_FILES">
            <xsd:documentation>how many journal files to pre-create
            </xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element name="journal-compact-percentage" type="xsd:int" default="30" maxOccurs="1" minOccurs="0">
          <xsd:annotation hq:linkend="configuring.message.journal.journal-compact-percentage"
                          hq:field_name="DEFAULT_JOURNAL_COMPACT_PERCENTAGE">
            <xsd:documentation>The percentage of live data on which we consider compacting the
            journal
            </xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element name="journal-compact-min-files" type="xsd:int" default="10" maxOccurs="1" minOccurs="0">
          <xsd:annotation hq:linkend="configuring.message.journal.journal-compact-min-files"
                          hq:field_name="DEFAULT_JOURNAL_COMPACT_MIN_FILES">
            <xsd:documentation>The minimal number of data files before we can start compacting
            </xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element name="journal-max-io" type="xsd:int" maxOccurs="1" minOccurs="0">
          <xsd:annotation hq:linkend="configuring.message.journal.journal-max-io">
            <xsd:documentation>the maximum number of write requests that can be in the AIO queue at
            any one time. Default is 500 for AIO and 1 for NIO.</xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element name="perf-blast-pages" type="xsd:int" default="-1" maxOccurs="1" minOccurs="0">
          <xsd:annotation hq:linkend="XXX" hq:field_name="DEFAULT_JOURNAL_PERF_BLAST_PAGES">
            <xsd:documentation>XXX Only meant to be used by project developers</xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element name="run-sync-speed-test" type="xsd:boolean" default="false" maxOccurs="1" minOccurs="0">
          <xsd:annotation hq:linkend="XXX" hq:field_name="DEFAULT_RUN_SYNC_SPEED_TEST">
            <xsd:documentation>XXX Only meant to be used by project developers</xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element name="server-dump-interval" type="xsd:long" default="-1" maxOccurs="1" minOccurs="0">
          <xsd:annotation hq:linkend="XXX" hq:default="(ms)"
                          hq:field_name="DEFAULT_SERVER_DUMP_INTERVAL">
            <xsd:documentation>Interval to log server specific information (e.g. memory usage
            etc)</xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element name="memory-warning-threshold" type="xsd:int" default="25" maxOccurs="1" minOccurs="0">
          <xsd:annotation hq:linkend="perf-tuning.memory"
                          hq:field_name="DEFAULT_MEMORY_WARNING_THRESHOLD">
            <xsd:documentation>Percentage of available memory which will trigger a warning log
            </xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element name="memory-measure-interval" type="xsd:long" default="-1" maxOccurs="1" minOccurs="0">
          <xsd:annotation hq:linkend="perf-tuning.memory" hq:default="(ms)"
                          hq:field_name="DEFAULT_MEMORY_MEASURE_INTERVAL">
            <xsd:documentation>frequency to sample JVM memory in ms (or -1 to disable memory sampling)</xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element name="large-messages-directory" type="xsd:string" default="data/largemessages"
                     maxOccurs="1" minOccurs="0">
          <xsd:annotation hq:linkend="large.message.configuring" hq:field_name="DEFAULT_LARGE_MESSAGES_DIR">
            <xsd:documentation>the directory to store large messages
            </xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element name="security-settings" maxOccurs="1" minOccurs="0">
          <xsd:annotation hq:linkend="security.settings.roles">
            <xsd:documentation>a list of security settings
            </xsd:documentation>
          </xsd:annotation>
          <xsd:complexType>
            <xsd:sequence>
              <xsd:element name="security-setting" maxOccurs="unbounded" minOccurs="0">
                <xsd:complexType>
                  <xsd:annotation>
                    <xsd:documentation>a permission to add to the matched addresses</xsd:documentation>
                  </xsd:annotation>
                  <xsd:sequence>
                    <xsd:element name="permission" maxOccurs="unbounded" minOccurs="0">
                      <xsd:complexType>
                        <xsd:attribute name="type" type="xsd:string" use="required">
                          <xsd:annotation>
                            <xsd:documentation>the type of permission</xsd:documentation>
                          </xsd:annotation>
                        </xsd:attribute>
                        <xsd:attribute name="roles" type="xsd:string" use="required">
                          <xsd:annotation>
                            <xsd:documentation>a comma-separated list of roles to apply the
                            permission to</xsd:documentation>
                          </xsd:annotation>
                        </xsd:attribute>
                      </xsd:complexType>
                    </xsd:element>
                  </xsd:sequence>
                  <xsd:attribute name="match" type="xsd:string" use="required">
                  <xsd:annotation>
                    <xsd:documentation>regular expression for matching security roles against
                    addresses</xsd:documentation>
                  </xsd:annotation>
                  </xsd:attribute>
                </xsd:complexType>
              </xsd:element>
            </xsd:sequence>
          </xsd:complexType>
        </xsd:element>

        <xsd:element name="address-settings" maxOccurs="1" minOccurs="0">
          <xsd:annotation hq:linkend="queue-attributes.address-settings">
            <xsd:documentation>a list of address settings
            </xsd:documentation>
          </xsd:annotation>
          <xsd:complexType>
            <xsd:sequence>
              <xsd:element ref="address-setting" maxOccurs="unbounded" minOccurs="0"/>
            </xsd:sequence>
          </xsd:complexType>
        </xsd:element>

        <xsd:element name="connector-services" maxOccurs="1" minOccurs="0">
          <xsd:complexType>
            <xsd:sequence>
              <xsd:element name="connector-service" type="connector-serviceType" maxOccurs="unbounded" minOccurs="0" />
            </xsd:sequence>
          </xsd:complexType>
        </xsd:element>

        <xsd:element name="backup-servers" maxOccurs="1" minOccurs="0">
          <xsd:complexType>
            <xsd:sequence>
               <xsd:element name="backup-server" type="backup-serverType" maxOccurs="unbounded" minOccurs="0"/>
            </xsd:sequence>
          </xsd:complexType>
        </xsd:element>
      </xsd:all>
    </xsd:complexType>

  <xsd:element name="local-bind-address" type="xsd:string">
    <xsd:annotation hq:default="wildcard IP address chosen by the kernel">
      <xsd:documentation>local bind address that the datagram socket is bound to</xsd:documentation>
    </xsd:annotation>
  </xsd:element>

  <xsd:element name="local-bind-port" type="xsd:int" default="-1">
    <xsd:annotation hq:default="(anonymous port)">
      <xsd:documentation>
        local port to which the datagram socket is bound to
      </xsd:documentation>
    </xsd:annotation>
  </xsd:element>

  <!-- BROADCAST GROUP CONFIGURATION -->
  <xsd:element name="broadcast-group">
    <xsd:complexType>
      <xsd:sequence>
        <!-- XXX these 2 local-* here...-->
        <xsd:element ref="local-bind-address"  maxOccurs="1" minOccurs="0" />
        <xsd:element ref="local-bind-port" maxOccurs="1" minOccurs="0"/>
        <xsd:element name="group-address" type="xsd:string" maxOccurs="1" minOccurs="0">
          <xsd:annotation>
            <xsd:documentation>multicast address to which the data will be broadcast</xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element name="group-port" type="xsd:int" maxOccurs="1" minOccurs="0">
          <xsd:annotation>
            <xsd:documentation>UDP port number used for broadcasting</xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element name="broadcast-period" type="xsd:long" default="2000" maxOccurs="1" minOccurs="0">
          <xsd:annotation hq:default="(in milliseconds)" hq:field_name="DEFAULT_BROADCAST_PERIOD">
            <xsd:documentation>period in milliseconds between consecutive broadcasts</xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element name="jgroups-file" type="xsd:string" maxOccurs="1" minOccurs="0">
          <xsd:annotation hq:linkend="clusters.jgroups-file">
            <xsd:documentation>Name of JGroups configuration file. If specified, the server uses JGroups for broadcasting.</xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element name="jgroups-channel" type="xsd:string" maxOccurs="1" minOccurs="0">
          <xsd:annotation hq:linkend="clusters.jgroups-example">
            <xsd:documentation>Name of JGroups Channel. If specified, the server uses the named
            channel for broadcasting.</xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element name="connector-ref" type="xsd:string" maxOccurs="unbounded" minOccurs="0"/>
      </xsd:sequence>

      <xsd:attribute name="name" type="xsd:ID" use="required">
        <xsd:annotation>
          <xsd:documentation>a unique name for the broadcast group</xsd:documentation>
        </xsd:annotation>
      </xsd:attribute>

    </xsd:complexType>
  </xsd:element>

  <xsd:element name="discovery-group">
    <xsd:complexType>
      <xsd:all>
        <!-- XXX -->
        <xsd:element name="group-address" type="xsd:string" maxOccurs="1" minOccurs="0">
          <xsd:annotation>
            <xsd:documentation>Multicast IP address of the group to listen on</xsd:documentation>
          </xsd:annotation>
        </xsd:element>
        <xsd:element name="group-port" type="xsd:int" maxOccurs="1" minOccurs="0">
          <xsd:annotation>
            <xsd:documentation>UDP port number of the multi cast group</xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element name="jgroups-file" type="xsd:string" maxOccurs="1" minOccurs="0">
          <xsd:annotation hq:linkend="clusters.jgroups-file">
            <xsd:documentation>Name of a JGroups configuration file. If specified, the server uses JGroups for discovery.</xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element name="jgroups-channel" type="xsd:string" maxOccurs="1" minOccurs="0">
          <xsd:annotation hq:linkend="clusters.jgroups-example">
            <xsd:documentation>Name of a JGroups Channel. If specified, the server uses the named channel for discovery.</xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element name="refresh-timeout" type="xsd:int" default="10000" maxOccurs="1" minOccurs="0">
          <xsd:annotation hq:linkend="configuration.discovery-group.refresh-timeout"
                          hq:default="(in milliseconds)"
                          hq:field_name="DEFAULT_BROADCAST_REFRESH_TIMEOUT">
            <xsd:documentation>Period the discovery group waits after receiving the last broadcast
            from a particular server before removing that servers connector pair entry from its
            list.</xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element ref="local-bind-address"   maxOccurs="1" minOccurs="0" />
        <xsd:element ref="local-bind-port"   maxOccurs="1" minOccurs="0" />
        <xsd:element name="initial-wait-timeout" type="xsd:int" default="10000" maxOccurs="1" minOccurs="0">
          <xsd:annotation hq:default="(milliseconds)" hq:linkend="XXX">
            <xsd:documentation>time to wait for an initial broadcast to give us at least one node in the cluster</xsd:documentation>
          </xsd:annotation>
        </xsd:element>
      </xsd:all>

      <xsd:attribute name="name" type="xsd:ID" use="required">
        <xsd:annotation>
          <xsd:documentation>a unique name for the discovery group</xsd:documentation>
        </xsd:annotation>
      </xsd:attribute>
    </xsd:complexType>
  </xsd:element>

  <xsd:element name="discovery-group-ref">
    <xsd:complexType>
      <xsd:attribute name="discovery-group-name" type="xsd:IDREF" />
    </xsd:complexType>
  </xsd:element>

  <xsd:complexType name="class-name-sequenceType">
    <xsd:annotation>
      <xsd:documentation>unlimited sequence of &lt;class-name/&gt;</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element maxOccurs="unbounded" minOccurs="1" name="class-name" type="xsd:string">
        <xsd:annotation>
          <xsd:documentation>the fully qualified name of the interceptor class</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:complexType>

  <xsd:complexType name="paramType">
    <xsd:attribute name="key" type="xsd:string" use="required">
      <xsd:annotation>
        <xsd:documentation>Key of a configuration parameter</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="value" type="xsd:string" use="required">
      <xsd:annotation>
      <xsd:documentation>Value of a configuration parameter</xsd:documentation>
    </xsd:annotation>
    </xsd:attribute>
  </xsd:complexType>

  <!-- BRIDGE CONFIGURATION -->
  <xsd:complexType name="bridgeType">
    <xsd:sequence>
      <xsd:element name="queue-name" type="xsd:IDREF" maxOccurs="1" minOccurs="1"  >
        <xsd:annotation>
          <xsd:documentation>name of queue that this bridge consumes from
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>

      <xsd:element name="forwarding-address" type="xsd:string" maxOccurs="1" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>address to forward to. If omitted original address is
          used</xsd:documentation>
        </xsd:annotation>
      </xsd:element>

      <xsd:element name="ha" type="xsd:boolean" default="false" maxOccurs="1" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>whether this bridge supports fail-over</xsd:documentation>
        </xsd:annotation>
      </xsd:element>

      <xsd:element ref="filter" maxOccurs="1" minOccurs="0"/>

      <xsd:element name="transformer-class-name" type="xsd:string"    maxOccurs="1" minOccurs="0"    >
        <xsd:annotation>
          <xsd:documentation>optional name of transformer class</xsd:documentation>
        </xsd:annotation>
      </xsd:element>

      <xsd:element name="min-large-message-size" type="xsd:int" default="102400" maxOccurs="1" minOccurs="0">
      <xsd:annotation hq:default="(bytes)">
        <xsd:documentation>Any message larger than this size is considered a large message (to be sent in
        chunks)</xsd:documentation>
      </xsd:annotation>
      </xsd:element>

      <xsd:element name="check-period" type="xsd:long" default="30000" maxOccurs="1" minOccurs="0">
        <xsd:annotation hq:linkend="connection-ttl" hq:default="(ms)">
          <xsd:documentation>The period (in milliseconds) a bridge's client will check if it failed
          to receive a ping from the server. -1 disables this check.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>

      <xsd:element name="connection-ttl" type="xsd:long" default="60000" maxOccurs="1" minOccurs="0">
        <xsd:annotation hq:linkend="connection-ttl" hq:default="(ms)" hq:field_name="DEFAULT_CONNECTION_TTL">
          <xsd:documentation>how long to keep a connection alive in the absence of any data arriving
          from the client. This should be greater than the ping period.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>

      <xsd:element name="retry-interval" type="xsd:long" default="2000" maxOccurs="1" minOccurs="0">
        <xsd:annotation hq:default="(in milliseconds)">
          <xsd:documentation>period (in ms) between successive retries</xsd:documentation>
        </xsd:annotation>
      </xsd:element>

      <xsd:element name="retry-interval-multiplier" type="xsd:double" default="1" maxOccurs="1" minOccurs="0">
        <xsd:annotation hq:field_name="DEFAULT_RETRY_INTERVAL_MULTIPLIER">
          <xsd:documentation>multiplier to apply to successive retry intervals</xsd:documentation>
        </xsd:annotation>
      </xsd:element>

      <xsd:element name="max-retry-interval" type="xsd:long" default="2000" maxOccurs="1" minOccurs="0">
        <xsd:annotation hq:field_name="DEFAULT_MAX_RETRY_INTERVAL">
          <xsd:documentation>Limit to the retry-interval growth (due to retry-interval-multiplier)</xsd:documentation>
        </xsd:annotation>
      </xsd:element>

      <xsd:element name="initial-connect-attempts" type="xsd:int" default="-1" maxOccurs="1" minOccurs="0">
        <xsd:annotation hq:field_name="DEFAULT_BRIDGE_INITIAL_CONNECT_ATTEMPTS">
          <xsd:documentation>maximum number of initial connection attempts, -1 means 'no limits'</xsd:documentation>
        </xsd:annotation>
      </xsd:element>

      <xsd:element name="reconnect-attempts" type="xsd:int" default="-1" maxOccurs="1" minOccurs="0">
        <xsd:annotation hq:field_name="DEFAULT_BRIDGE_RECONNECT_ATTEMPTS">
          <xsd:documentation>maximum number of retry attempts, -1 means 'no limits'</xsd:documentation>
        </xsd:annotation>
      </xsd:element>

      <xsd:element name="failover-on-server-shutdown" type="xsd:boolean" default="false" maxOccurs="1" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>should failover be prompted if target server is cleanly
          shutdown?</xsd:documentation>
        </xsd:annotation>
      </xsd:element>

      <xsd:element name="use-duplicate-detection" type="xsd:boolean" default="true"
                   maxOccurs="1" minOccurs="0">
        <xsd:annotation hq:field_name="DEFAULT_BRIDGE_DUPLICATE_DETECTION">
          <xsd:documentation>should duplicate detection headers be inserted in forwarded
          messages?</xsd:documentation>
        </xsd:annotation>
      </xsd:element>

      <xsd:element name="confirmation-window-size" type="xsd:int"     maxOccurs="1" minOccurs="0">
        <xsd:annotation hq:default="(bytes, 1024 * 1024)">
          <xsd:documentation>Once the bridge has received this many
          bytes, it sends a confirmation</xsd:documentation>
        </xsd:annotation>
      </xsd:element>

      <xsd:element name="user" type="xsd:string" maxOccurs="1" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>username, if unspecified the cluster-user is used</xsd:documentation>
        </xsd:annotation>
      </xsd:element>

      <xsd:element name="password" type="xsd:string" maxOccurs="1" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>password, if unspecified the cluster-password is used</xsd:documentation>
        </xsd:annotation>
      </xsd:element>

      <xsd:element name="reconnect-attempts-same-node" default="10" type="xsd:int"
                   maxOccurs="1" minOccurs="0">
        <xsd:annotation hq:default="(int, 10)" hq:field_name="DEFAULT_BRIDGE_CONNECT_SAME_NODE">
          <xsd:documentation>
            Upon reconnection this configures the number of time the same node on the topology will
            be retried before reseting the server locator and using the initial
            connectors</xsd:documentation>
        </xsd:annotation>
      </xsd:element>

      <xsd:choice>
        <xsd:element name="static-connectors" maxOccurs="1" minOccurs="1">
          <xsd:complexType>
            <xsd:sequence>
              <xsd:element name="connector-ref" type="xsd:string" maxOccurs="unbounded" minOccurs="1"/>
            </xsd:sequence>
          </xsd:complexType>
        </xsd:element>
        <xsd:element name="discovery-group-ref" maxOccurs="1" minOccurs="1">
          <xsd:complexType>
            <xsd:attribute name="discovery-group-name" type="xsd:IDREF" use="required">
              <xsd:annotation>
                <xsd:documentation>name of discovery group used by this bridge</xsd:documentation>
              </xsd:annotation>
            </xsd:attribute>
          </xsd:complexType>
        </xsd:element>
      </xsd:choice>
    </xsd:sequence>

    <xsd:attribute name="name" type="xsd:ID" use="required">
      <xsd:annotation>
        <xsd:documentation>unique name for this bridge
        </xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
  </xsd:complexType>


  <!-- CLUSTER CONNECTION CONFIGURATION -->

  <xsd:complexType  name="cluster-connectionType">
    <xsd:sequence>
      <xsd:element name="address" type="xsd:string" maxOccurs="1" minOccurs="1">
        <xsd:annotation>
          <xsd:documentation>name of the address this cluster connection applies
          to</xsd:documentation>
        </xsd:annotation>
      </xsd:element>

      <xsd:element name="connector-ref" type="xsd:string" maxOccurs="1" minOccurs="1">
        <xsd:annotation>
          <xsd:documentation>Name of the connector reference to use.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>

      <xsd:element name="check-period" type="xsd:long" default="30000" maxOccurs="1" minOccurs="0">
        <xsd:annotation hq:linkend="connection-ttl" hq:default="(ms)"
                        hq:field_name="DEFAULT_CLUSTER_FAILURE_CHECK_PERIOD">
          <xsd:documentation>The period (in milliseconds) used to check if the cluster connection
          has failed to receive pings from another server</xsd:documentation>
        </xsd:annotation>
      </xsd:element>

      <xsd:element name="connection-ttl" type="xsd:long" default="60000" maxOccurs="1" minOccurs="0">
        <xsd:annotation hq:linkend="connection-ttl" hq:default="(ms)"
                        hq:field_name="DEFAULT_CLUSTER_CONNECTION_TTL">
          <xsd:documentation>how long to keep a connection alive in the absence of any data arriving
          from the client</xsd:documentation>
        </xsd:annotation>
      </xsd:element>

      <xsd:element name="min-large-message-size" type="xsd:int" maxOccurs="1" minOccurs="0">
        <xsd:annotation hq:linkend="large-messages" hq:default="(bytes)">
          <xsd:documentation>Messages larger than this are considered large-messages</xsd:documentation>
        </xsd:annotation>
      </xsd:element>

      <xsd:element name="call-timeout" type="xsd:long" default="30000" maxOccurs="1" minOccurs="0">
        <xsd:annotation hq:default="(ms)">
          <xsd:documentation>How long to wait for a reply</xsd:documentation>
        </xsd:annotation>
      </xsd:element>

      <xsd:element name="retry-interval" type="xsd:long" default="500" maxOccurs="1" minOccurs="0">
        <xsd:annotation hq:field_name="DEFAULT_CLUSTER_RETRY_INTERVAL">
          <xsd:documentation>period (in ms) between successive retries</xsd:documentation>
        </xsd:annotation>
      </xsd:element>

      <xsd:element name="retry-interval-multiplier" type="xsd:double" default="1" maxOccurs="1" minOccurs="0">
        <xsd:annotation hq:field_name="DEFAULT_CLUSTER_RETRY_INTERVAL_MULTIPLIER">
          <xsd:documentation>multiplier to apply to the retry-interval</xsd:documentation>
        </xsd:annotation>
      </xsd:element>

      <xsd:element name="max-retry-interval" type="xsd:long" default="2000" maxOccurs="1" minOccurs="0">
        <xsd:annotation hq:field_name="DEFAULT_CLUSTER_MAX_RETRY_INTERVAL">
          <xsd:documentation>Maximum value for retry-interval</xsd:documentation>
        </xsd:annotation>
      </xsd:element>

      <xsd:element name="initial-connect-attempts" type="xsd:int" default="-1" maxOccurs="1" minOccurs="0">
        <xsd:annotation hq:field_name="DEFAULT_CLUSTER_INITIAL_CONNECT_ATTEMPTS">
          <xsd:documentation>How many attempts should be made to connect initially</xsd:documentation>
        </xsd:annotation>
      </xsd:element>

      <xsd:element name="reconnect-attempts" type="xsd:int" default="-1" maxOccurs="1" minOccurs="0">
        <xsd:annotation hq:field_name="DEFAULT_CLUSTER_RECONNECT_ATTEMPTS">
          <xsd:documentation>How many attempts should be made to
          reconnect after failure</xsd:documentation>
        </xsd:annotation>
      </xsd:element>

      <xsd:element name="use-duplicate-detection" type="xsd:boolean" default="true" maxOccurs="1" minOccurs="0">
        <xsd:annotation hq:field_name="DEFAULT_CLUSTER_DUPLICATE_DETECTION">
          <xsd:documentation>should duplicate detection headers be inserted in forwarded
          messages?</xsd:documentation>
        </xsd:annotation>
      </xsd:element>

      <xsd:element name="forward-when-no-consumers" type="xsd:boolean" default="false" maxOccurs="1" minOccurs="0">
        <xsd:annotation hq:field_name="DEFAULT_CLUSTER_FORWARD_WHEN_NO_CONSUMERS">
          <xsd:documentation>should messages be load balanced if there are no matching consumers on
          target?</xsd:documentation>
        </xsd:annotation>
      </xsd:element>

      <xsd:element name="max-hops" type="xsd:int" default="1" maxOccurs="1" minOccurs="0">
        <xsd:annotation hq:field_name="DEFAULT_CLUSTER_MAX_HOPS">
          <xsd:documentation>maximum number of hops cluster topology is
          propagated</xsd:documentation>
        </xsd:annotation>
      </xsd:element>

      <xsd:element name="confirmation-window-size" type="xsd:int" default="1048576" maxOccurs="1" minOccurs="0">
        <xsd:annotation hq:linkend="client-reconnection">
          <xsd:documentation>The size (in bytes) of the window used for confirming data from
          the server connected to.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>

      <xsd:element name="call-failover-timeout" type="xsd:long" default="-1" maxOccurs="1" minOccurs="0">
        <xsd:annotation hq:linkend="clusters.cluster-connections" hq:default="(ms)">
          <xsd:documentation>How long to wait for a reply if in the middle of a fail-over. -1 means
          wait forever.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>

      <xsd:element name="notification-interval" type="xsd:long" default="1000" maxOccurs="1" minOccurs="0">
        <xsd:annotation hq:default="(ms)" hq:field_name="DEFAULT_CLUSTER_NOTIFICATION_INTERVAL">
          <xsd:documentation>
            how often the cluster connection will notify the cluster of its existence right after joining the cluster
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="notification-attempts" type="xsd:int" default="2" maxOccurs="1" minOccurs="0">
        <xsd:annotation hq:field_name="DEFAULT_CLUSTER_NOTIFICATION_ATTEMPTS">
          <xsd:documentation>
            how many times this cluster connection will notify the cluster of its existence right after joining the cluster
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:choice>
        <xsd:element name="static-connectors" maxOccurs="1" minOccurs="0">
          <xsd:complexType>
            <xsd:sequence>
              <xsd:element name="connector-ref" type="xsd:string" maxOccurs="unbounded" minOccurs="0"/>
            </xsd:sequence>
            <xsd:attribute name="allow-direct-connections-only" default="false" type="xsd:boolean"
                           use="optional">
              <xsd:annotation>
                <xsd:documentation>restricts cluster connections to the
                listed connector-ref's</xsd:documentation>
              </xsd:annotation>
            </xsd:attribute>
          </xsd:complexType>
        </xsd:element>
        <xsd:element name="discovery-group-ref" maxOccurs="1" minOccurs="0">
          <xsd:complexType>
            <xsd:attribute name="discovery-group-name" type="xsd:IDREF" use="required">
              <xsd:annotation>
                <xsd:documentation>XXX -- this is a duplicate... </xsd:documentation>
              </xsd:annotation>
            </xsd:attribute>
          </xsd:complexType>
        </xsd:element>
      </xsd:choice>
    </xsd:sequence>
    <xsd:attribute name="name" type="xsd:ID" use="required">
      <xsd:annotation>
        <xsd:documentation>unique name for this cluster connection</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
  </xsd:complexType>

  <!-- DIVERT CONFIGURATION TYPE -->
  <xsd:complexType name="divertType">
    <xsd:all>
      <xsd:element name="transformer-class-name" type="xsd:string" maxOccurs="1" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>an optional class name of a transformer</xsd:documentation>
        </xsd:annotation>
      </xsd:element>

      <xsd:element name="exclusive" type="xsd:boolean" default="false" maxOccurs="1" minOccurs="0">
        <xsd:annotation hq:field_name="DEFAULT_DIVERT_EXCLUSIVE">
          <xsd:documentation>whether this is an exclusive divert</xsd:documentation>
        </xsd:annotation>
      </xsd:element>

      <xsd:element name="routing-name" type="xsd:string" maxOccurs="1" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>the routing name for the divert</xsd:documentation>
        </xsd:annotation>
      </xsd:element>

      <xsd:element name="address" type="xsd:string"            maxOccurs="1" minOccurs="1">
        <xsd:annotation>
          <xsd:documentation>the address this divert will divert from</xsd:documentation>
        </xsd:annotation>
      </xsd:element>

      <xsd:element name="forwarding-address" type="xsd:string" maxOccurs="1" minOccurs="1">
        <xsd:annotation>
          <xsd:documentation>the forwarding address for the divert</xsd:documentation>
        </xsd:annotation>
      </xsd:element>

      <xsd:element ref="filter" maxOccurs="1" minOccurs="0"/>
    </xsd:all>

    <xsd:attribute name="name" type="xsd:ID" use="required">
      <xsd:annotation>
        <xsd:documentation>a unique name for the divert</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>

  </xsd:complexType>

  <xsd:complexType name="groupingHandlerType">
    <xsd:all>
      <xsd:element name="type" maxOccurs="1" minOccurs="1">
        <xsd:annotation hq:linkend="message-grouping.type">
          <xsd:documentation>Each cluster should choose 1 node to
         have a LOCAL grouping handler and all the other nodes should
         have REMOTE handlers</xsd:documentation>
        </xsd:annotation>
        <xsd:simpleType>
          <xsd:restriction base="xsd:string">
            <xsd:enumeration value="LOCAL" />
            <xsd:enumeration value="REMOTE" />
          </xsd:restriction>
        </xsd:simpleType>
      </xsd:element>
      <xsd:element name="address" type="xsd:string" maxOccurs="1" minOccurs="1">
        <xsd:annotation hq:linkend="message-grouping.address">
          <xsd:documentation>A reference to a cluster connection address</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="timeout" type="xsd:int" default="5000" maxOccurs="1" minOccurs="0">
        <xsd:annotation hq:default="(ms)">
          <xsd:documentation>How long to wait for a decision</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="group-timeout" type="xsd:int" default="-1" maxOccurs="1" minOccurs="0">
        <xsd:annotation hq:default="(ms)">
          <xsd:documentation>How long a group binding will be used, -1 means for ever. Bindings are removed after this wait
             elapses. On the remote node this is used to determine how often you should re-query the main coordinator in order to update the last time used accordingly.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="reaper-period" type="xsd:long" default="30000" maxOccurs="1" minOccurs="0">
        <xsd:annotation hq:default="(ms)">
          <xsd:documentation>How often the reaper will be run to check for timed out group bindings. Only valid for LOCAL handlers</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:all>
    <xsd:attribute name="name" type="xsd:string" use="required">
      <xsd:annotation>
        <xsd:documentation>A name identifying this grouping-handler</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
  </xsd:complexType>

  <xsd:element name="address-setting">
  <xsd:complexType>
    <xsd:annotation hq:linkend="queue-attributes.address-settings">
      <xsd:documentation>Complex type element to configure an address.</xsd:documentation>
    </xsd:annotation>
      <xsd:all>
        <xsd:element maxOccurs="1" minOccurs="0" name="dead-letter-address" type="xsd:string">
          <xsd:annotation hq:linkend="undelivered-messages.configuring">
            <xsd:documentation>the address to send dead messages to</xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element name="expiry-address" type="xsd:string" maxOccurs="1" minOccurs="0">
          <xsd:annotation hq:linkend="message-expiry.configuring">
            <xsd:documentation>the address to send expired messages to</xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element name="expiry-delay" type="xsd:long" default="-1" maxOccurs="1" minOccurs="0">
          <xsd:annotation>
            <xsd:documentation>Overrides the expiration time for
            messages using the default value for expiration time. "-1"
            disables this setting.</xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element name="redelivery-delay" type="xsd:long" default="0" maxOccurs="1" minOccurs="0">
          <xsd:annotation hq:linkend="undelivered-messages.delay">
            <xsd:documentation>the time (in ms) to wait before redelivering a cancelled
            message.</xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element name="redelivery-delay-multiplier" type="xsd:double"  maxOccurs="1" minOccurs="0">
          <xsd:annotation>
            <xsd:documentation>multipler to apply to the "redelivery-delay"</xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element name="max-redelivery-delay" type="xsd:long"  maxOccurs="1" minOccurs="0">
          <xsd:annotation>
            <xsd:documentation>Maximum value for the redelivery-delay</xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element name="max-delivery-attempts" type="xsd:int" default="10" maxOccurs="1" minOccurs="0">
          <xsd:annotation hq:linkend="undelivered-messages.configuring">
            <xsd:documentation>how many times to attempt to deliver a message before sending to dead
            letter address</xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element name="max-size-bytes" type="xsd:long" default="-1"  maxOccurs="1" minOccurs="0">
          <xsd:annotation hq:linkend="paging">
            <xsd:documentation>the maximum size (in bytes) to use in paging for an
            address (-1 means no limits)</xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element name="page-size-bytes" type="xsd:long" default="10485760" maxOccurs="1" minOccurs="0">
          <xsd:annotation hq:linkend="paging" hq:default="(10 * 1024 * 1024)">
            <xsd:documentation>the page size (in bytes) to use for an address</xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element  name="page-max-cache-size" default="5" type="xsd:int"  maxOccurs="1" minOccurs="0">
          <xsd:annotation hq:linkend="paging">
            <xsd:documentation>Number of paging files to cache in
            memory to avoid IO during paging navigation</xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element name="address-full-policy" maxOccurs="1" minOccurs="0">
          <xsd:annotation>
            <xsd:documentation>what happens when an address where "max-size-bytes" is specified
            becomes full</xsd:documentation>
          </xsd:annotation>
          <xsd:simpleType>
            <xsd:restriction base="xsd:string">
              <xsd:enumeration value="DROP" />
              <xsd:enumeration value="FAIL" />
              <xsd:enumeration value="PAGE" />
              <xsd:enumeration value="BLOCK" />
            </xsd:restriction>
          </xsd:simpleType>
        </xsd:element>

        <xsd:element name="message-counter-history-day-limit" type="xsd:int" default="0" maxOccurs="1" minOccurs="0">
          <xsd:annotation hq:default="(days)">
            <xsd:documentation>how many days to keep message counter history for this address</xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element name="last-value-queue" type="xsd:boolean" default="false" maxOccurs="1" minOccurs="0">
          <xsd:annotation hq:linkend="last-value-queues">
            <xsd:documentation>whether to treat the queue as a last value queue</xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element name="redistribution-delay" type="xsd:long" default="-1" maxOccurs="1" minOccurs="0">
          <xsd:annotation hq:linkend="clusters">
            <xsd:documentation>how long (in ms) to wait after the last consumer is closed on a
            queue before redistributing messages.</xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element name="send-to-dla-on-no-route" type="xsd:boolean"  maxOccurs="1" minOccurs="0">
          <xsd:annotation>
            <xsd:documentation>if there are no queues matching this address, whether to forward message to DLA (if it exists for this address)</xsd:documentation>
          </xsd:annotation>
        </xsd:element>
      </xsd:all>

      <xsd:attribute name="match" type="xsd:string" use="required">
        <xsd:annotation>
          <xsd:documentation>XXX</xsd:documentation>
        </xsd:annotation>
      </xsd:attribute>
    </xsd:complexType>
</xsd:element>

  <xsd:element name="filter">
    <xsd:complexType>
      <xsd:annotation>
        <xsd:documentation>optional core filter expression (set through attribute)</xsd:documentation>
      </xsd:annotation>
      <xsd:attribute name="string" type="xsd:string" use="required">
        <xsd:annotation>
          <xsd:documentation>optional core filter expression</xsd:documentation>
        </xsd:annotation>
      </xsd:attribute>
    </xsd:complexType>
</xsd:element>

  <xsd:complexType name="connector-serviceType">
    <xsd:sequence>
      <xsd:element maxOccurs="1" minOccurs="1" name="factory-class" type="xsd:string">
        <xsd:annotation>
          <xsd:documentation>Name of the factory class of the ConnectorService</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element maxOccurs="unbounded" minOccurs="0" name="param" type="paramType" />
    </xsd:sequence>
    <xsd:attribute name="name" type="xsd:string" use="optional">
      <xsd:annotation>
        <xsd:documentation>name of the connector service</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
  </xsd:complexType>

  <xsd:complexType name="backup-serverType">
    <xsd:sequence>
      <xsd:element maxOccurs="1" minOccurs="0" name="configuration" type="configurationType">
        <xsd:annotation>
          <xsd:documentation>The configuration to override</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    <xsd:element maxOccurs="unbounded" minOccurs="0" name="param" type="paramType" />
    </xsd:sequence>
    <xsd:attribute name="name" type="xsd:string" use="required">
      <xsd:annotation>
        <xsd:documentation>name of the backup server, this will be used to identify the backup server and also appended to
        the journal directories if not supplied.</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="port-offset" type="xsd:integer" use="optional" default="100">
      <xsd:annotation>
        <xsd:documentation>the port offset use to adjust the connector and acceptor ports</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="inherit-configuration" type="xsd:boolean" use="optional" default="true">
      <xsd:annotation>
        <xsd:documentation>if true then the backup will use the same configuration as the live server.</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
  </xsd:complexType>

</xsd:schema>
